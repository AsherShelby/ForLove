<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cyber Particles x Hand Gestures</title>
    <style>
        :root {
            --primary: #00f3ff;
            --secondary: #bc13fe;
            --bg: #050505;
        }
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Segoe UI', sans-serif;
            color: white;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        .hud-text {
            text-shadow: 0 0 10px var(--primary);
            font-size: 14px;
            opacity: 0.8;
            pointer-events: auto;
        }
        .status-badge {
            display: inline-flex;
            align-items: center;
            background: rgba(0,0,0,0.6);
            border: 1px solid var(--primary);
            padding: 8px 16px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }
        .status-dot {
            width: 10px;
            height: 10px;
            background: #333;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 5px #333;
            transition: all 0.3s;
        }
        .status-dot.active {
            background: #0f0;
            box-shadow: 0 0 8px #0f0;
        }
        .status-dot.error {
            background: #f00;
            box-shadow: 0 0 8px #f00;
        }
        
        /* Loading Screen */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.8s ease;
        }
        .spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(0, 243, 255, 0.3);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .loader-text {
            margin-top: 20px;
            font-size: 16px;
            letter-spacing: 2px;
            color: var(--primary);
            text-transform: uppercase;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Controls */
        #controls {
            position: absolute;
            bottom: 30px;
            right: 30px;
            pointer-events: auto;
            display: flex;
            gap: 10px;
        }
        button {
            background: rgba(0,0,0,0.7);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 10px 20px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover {
            background: var(--primary);
            color: black;
            box-shadow: 0 0 15px var(--primary);
        }
        
        #video-preview {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 160px;
            height: 120px;
            border: 1px solid var(--secondary);
            opacity: 0.8;
            transform: scaleX(-1); /* Mirror */
            display: none;
            pointer-events: auto;
        }
        
        .gesture-guide {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            text-align: right;
            border-right: 2px solid var(--secondary);
        }
        .guide-item {
            margin-bottom: 8px;
            font-size: 12px;
            color: #ddd;
        }
        .guide-item span { color: var(--secondary); font-weight: bold; }

    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text" id="loader-msg">Initializing Core...</div>
    </div>

    <div id="ui-layer">
        <div class="status-badge">
            <div class="status-dot" id="cam-status"></div>
            <span id="status-text">Waiting for Camera...</span>
        </div>

        <div class="gesture-guide">
            <div class="guide-item">‚úä Fist: <span>Heart</span></div>
            <div class="guide-item">üñê Open: <span>Explode</span></div>
            <div class="guide-item">‚úåÔ∏è Victory: <span>Star</span></div>
            <div class="guide-item">ü§ò Rock: <span>Note ‚ô´</span></div>
            <div class="guide-item">ü§ö Palm+Thumb In: <span>LOVE</span></div>
        </div>

        <video id="video-preview" playsinline></video>

        <div id="controls">
            <button id="toggle-cam">Toggle Cam</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Config ---
        const PARTICLE_COUNT = 12000;
        const PARTICLE_SIZE = 4.0;
        const EXPLOSION_FORCE = 2.0;
        const ATTRACTION_STRENGTH = 0.08; // How fast particles fly to shape
        const FRICTION = 0.92;
        
        // --- State Management ---
        const state = {
            gesture: 'None',
            targetShape: 'sphere', // sphere, heart, star, note, love
            isExploding: false,
            cameraActive: false,
            time: 0
        };

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 60;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.enableZoom = false;

        // --- Particle System ---
        // We use BufferGeometry for performance
        const geometry = new THREE.BufferGeometry();
        
        // Attributes: Position (current), Target (destination), Velocity, Color, Size
        const posArray = new Float32Array(PARTICLE_COUNT * 3);
        const targetArray = new Float32Array(PARTICLE_COUNT * 3);
        const velocityArray = new Float32Array(PARTICLE_COUNT * 3);
        const colorArray = new Float32Array(PARTICLE_COUNT * 3);
        const sizeArray = new Float32Array(PARTICLE_COUNT);

        // Initialize Randomly
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            // Random sphere distribution
            const r = 40 * Math.cbrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);

            posArray[i3] = r * Math.sin(phi) * Math.cos(theta);
            posArray[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            posArray[i3 + 2] = r * Math.cos(phi);

            // Set Initial Targets (same as pos)
            targetArray[i3] = posArray[i3];
            targetArray[i3 + 1] = posArray[i3 + 1];
            targetArray[i3 + 2] = posArray[i3 + 2];

            // Velocity 0
            velocityArray[i3] = 0;
            velocityArray[i3 + 1] = 0;
            velocityArray[i3 + 2] = 0;

            // Colors (Initial Blue/Purple)
            const color = new THREE.Color().setHSL(0.5 + Math.random() * 0.2, 0.8, 0.6);
            colorArray[i3] = color.r;
            colorArray[i3 + 1] = color.g;
            colorArray[i3 + 2] = color.b;

            sizeArray[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        geometry.setAttribute('target', new THREE.BufferAttribute(targetArray, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizeArray, 1));

        // --- Custom Shader Material ---
        // Allows for glowing sprites, size attenuation, and color mixing on GPU
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uPixelRatio: { value: renderer.getPixelRatio() },
                uSize: { value: PARTICLE_SIZE },
                uColorExplosion: { value: new THREE.Color(0xffaa00) }, // Gold/Fire
                uColorHeart: { value: new THREE.Color(0xff0055) },     // Red
                uColorStar: { value: new THREE.Color(0xffee00) },      // Yellow
                uColorNote: { value: new THREE.Color(0x00ffcc) },      // Cyan
                uColorLove: { value: new THREE.Color(0xff00ff) },      // Magenta
                uMode: { value: 0.0 } // 0: Normal, 1: Explode mix
            },
            vertexShader: `
                uniform float uTime;
                uniform float uPixelRatio;
                uniform float uSize;
                
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    
                    // Size attenuation based on depth
                    gl_PointSize = (uSize * size * uPixelRatio * 40.0) / -mvPosition.z;
                    
                    // Simple breathing effect
                    float breath = 1.0 + sin(uTime * 2.0 + position.x) * 0.1;
                    gl_PointSize *= breath;

                    gl_Position = projectionMatrix * mvPosition;
                    
                    // Fade out particles that are too close
                    vAlpha = smoothstep(0.0, 5.0, -mvPosition.z);
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    // Create circular sprite with soft edge
                    vec2 uv = gl_PointCoord - 0.5;
                    float r = length(uv);
                    if (r > 0.5) discard;

                    // Glow effect: center bright, edges soft
                    float glow = 1.0 - (r * 2.0);
                    glow = pow(glow, 2.0);

                    gl_FragColor = vec4(vColor, vAlpha * glow);
                }
            `,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            transparent: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Background Stars ---
        const bgGeo = new THREE.BufferGeometry();
        const bgCount = 2000;
        const bgPos = new Float32Array(bgCount * 3);
        for(let i=0; i<bgCount*3; i++) {
            bgPos[i] = (Math.random() - 0.5) * 400;
        }
        bgGeo.setAttribute('position', new THREE.BufferAttribute(bgPos, 3));
        const bgMat = new THREE.PointsMaterial({
            size: 1.5, color: 0x444444, transparent: true, opacity: 0.6, sizeAttenuation: true
        });
        const starField = new THREE.Points(bgGeo, bgMat);
        scene.add(starField);


        // --- Shape Generation Logic ---

        function getSpherePoint(i) {
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
            const r = 25;
            return {
                x: r * Math.cos(theta) * Math.sin(phi),
                y: r * Math.sin(theta) * Math.sin(phi),
                z: r * Math.cos(phi)
            };
        }

        function getHeartPoint(i) {
            // Parametric Heart
            const t = (i / PARTICLE_COUNT) * Math.PI * 2;
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            // Add Z depth
            const z = (Math.random() - 0.5) * 10; 
            // Scale
            return { x: x * 1.2, y: y * 1.2, z: z };
        }

        function getStarPoint(i) {
            // Parametric Star
            const t = (i / PARTICLE_COUNT) * Math.PI * 2 * 5; // 5 loops for 5 points
            const k = i / PARTICLE_COUNT;
            // Radius oscillates
            const r = 20 + 10 * Math.sin(5 * t); 
            // Need a bit of volume
            const z = (Math.random() - 0.5) * 5;
            return {
                x: r * Math.cos(t),
                y: r * Math.sin(t),
                z: z
            };
        }

        function getNotePoint(i) {
            // Approximate musical note (Two spheres + stem + beam)
            // Procedurally define regions based on index
            const ratio = i / PARTICLE_COUNT;
            let x, y, z;
            
            if (ratio < 0.2) { // Left Head
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                const r = 5;
                x = -10 + r * Math.sin(v) * Math.cos(u);
                y = -10 + r * Math.sin(v) * Math.sin(u);
                z = r * Math.cos(v);
            } else if (ratio < 0.4) { // Right Head
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                const r = 5;
                x = 10 + r * Math.sin(v) * Math.cos(u);
                y = -10 + r * Math.sin(v) * Math.sin(u);
                z = r * Math.cos(v);
            } else if (ratio < 0.6) { // Left Stem
                x = -6 + (Math.random() - 0.5) * 2;
                y = -10 + Math.random() * 25;
                z = (Math.random() - 0.5) * 2;
            } else if (ratio < 0.8) { // Right Stem
                x = 14 + (Math.random() - 0.5) * 2;
                y = -10 + Math.random() * 25;
                z = (Math.random() - 0.5) * 2;
            } else { // Beam
                x = -6 + Math.random() * 20;
                y = 15 + (Math.random() - 0.5) * 4 + (x * 0.2); // Slanted
                z = (Math.random() - 0.5) * 2;
            }
            return { x, y, z };
        }

        function getLovePoint(i) {
            // Mapping letters L O V E roughly
            const segment = Math.floor((i / PARTICLE_COUNT) * 4);
            const subRatio = ((i / PARTICLE_COUNT) * 4) % 1;
            let x=0, y=0, z=(Math.random()-0.5)*4;
            const spread = 2;

            if (segment === 0) { // L (x: -30 to -15)
                if (subRatio < 0.7) { // Vertical
                    x = -25 + (Math.random()-0.5)*spread;
                    y = -10 + subRatio/0.7 * 20;
                } else { // Horizontal
                    x = -25 + (subRatio-0.7)/0.3 * 10;
                    y = -10 + (Math.random()-0.5)*spread;
                }
            } else if (segment === 1) { // O (x: -10 to 5)
                const angle = subRatio * Math.PI * 2;
                x = -2.5 + 8 * Math.cos(angle);
                y = 0 + 8 * Math.sin(angle);
            } else if (segment === 2) { // V (x: 10 to 25)
                // V shape
                 if (subRatio < 0.5) {
                    x = 10 + subRatio/0.5 * 7;
                    y = 10 - subRatio/0.5 * 20;
                } else {
                    x = 17 + (subRatio-0.5)/0.5 * 7;
                    y = -10 + (subRatio-0.5)/0.5 * 20;
                }
            } else { // E (x: 30 to 45)
                 if (subRatio < 0.4) { // Vertical
                    x = 30 + (Math.random()-0.5)*spread;
                    y = -10 + subRatio/0.4 * 20;
                } else if (subRatio < 0.6) { // Top
                    x = 30 + (subRatio-0.4)/0.2 * 10;
                    y = 10 + (Math.random()-0.5)*spread;
                } else if (subRatio < 0.8) { // Mid
                    x = 30 + (subRatio-0.6)/0.2 * 8;
                    y = 0 + (Math.random()-0.5)*spread;
                } else { // Bot
                    x = 30 + (subRatio-0.8)/0.2 * 10;
                    y = -10 + (Math.random()-0.5)*spread;
                }
            }
            return { x, y, z };
        }

        function updateTargets(shape) {
            if (shape === state.targetShape && !state.isExploding) return;
            state.targetShape = shape;

            const targetAttr = geometry.attributes.target.array;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let p;
                switch (shape) {
                    case 'heart': p = getHeartPoint(i); break;
                    case 'star': p = getStarPoint(i); break;
                    case 'note': p = getNotePoint(i); break;
                    case 'love': p = getLovePoint(i); break;
                    default: p = getSpherePoint(i); break;
                }
                
                // Add some random noise to target to keep it organic
                const noise = 0.5;
                targetAttr[i * 3] = p.x + (Math.random()-0.5)*noise;
                targetAttr[i * 3 + 1] = p.y + (Math.random()-0.5)*noise;
                targetAttr[i * 3 + 2] = p.z + (Math.random()-0.5)*noise;
            }
            geometry.attributes.target.needsUpdate = true;
            
            // Set Color Target based on shape
            let targetColor = new THREE.Color();
            if (shape === 'heart') targetColor.setHex(0xff0055);
            else if (shape === 'star') targetColor.setHex(0xffdd00);
            else if (shape === 'note') targetColor.setHex(0x00ffcc);
            else if (shape === 'love') targetColor.setHex(0xe600ff);
            else targetColor.setHex(0x00f3ff);

            // Interpolate colors over time in the loop, but here we just set a flag or gradual change
            // For simplicity in this loop, we push colors to new hue
            const colors = geometry.attributes.color.array;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                // We keep current colors but they will shift in animation loop if we wanted.
                // For now, let's just let them be naturally varied or set them immediately for responsiveness
                const c = targetColor.clone();
                // Add variation
                c.offsetHSL((Math.random()-0.5)*0.1, 0, 0);
                colors[i*3] = c.r;
                colors[i*3+1] = c.g;
                colors[i*3+2] = c.b;
            }
            geometry.attributes.color.needsUpdate = true;
        }

        // --- Physics & Animation Loop ---

        function animateParticles() {
            const positions = geometry.attributes.position.array;
            const targets = geometry.attributes.target.array;
            
            // Mouse/Interaction forces could go here
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                let px = positions[i3];
                let py = positions[i3 + 1];
                let pz = positions[i3 + 2];
                
                let vx = velocityArray[i3];
                let vy = velocityArray[i3 + 1];
                let vz = velocityArray[i3 + 2];

                if (state.isExploding) {
                    // Explosion Physics: Push outward from center
                    // If near center, push hard. 
                    const dist = Math.sqrt(px*px + py*py + pz*pz) + 0.1;
                    const force = EXPLOSION_FORCE / dist;
                    vx += px * force * 0.05 + (Math.random()-0.5)*0.5;
                    vy += py * force * 0.05 + (Math.random()-0.5)*0.5;
                    vz += pz * force * 0.05 + (Math.random()-0.5)*0.5;
                } else {
                    // Shape Formation Physics (Spring/Attraction)
                    const tx = targets[i3];
                    const ty = targets[i3 + 1];
                    const tz = targets[i3 + 2];

                    const dx = tx - px;
                    const dy = ty - py;
                    const dz = tz - pz;

                    vx += dx * ATTRACTION_STRENGTH;
                    vy += dy * ATTRACTION_STRENGTH;
                    vz += dz * ATTRACTION_STRENGTH;
                    
                    // Add some curl noise/turbulence
                    vx += Math.sin(py * 0.1 + state.time) * 0.02;
                    vy += Math.cos(px * 0.1 + state.time) * 0.02;
                }

                // Apply Friction
                vx *= FRICTION;
                vy *= FRICTION;
                vz *= FRICTION;

                // Update Position
                positions[i3] += vx;
                positions[i3 + 1] += vy;
                positions[i3 + 2] += vz;

                // Save Velocity
                velocityArray[i3] = vx;
                velocityArray[i3 + 1] = vy;
                velocityArray[i3 + 2] = vz;
            }
            
            geometry.attributes.position.needsUpdate = true;
        }

        // --- MediaPipe Hands ---

        const video = document.getElementById('video-preview');
        const statusText = document.getElementById('status-text');
        const statusDot = document.getElementById('cam-status');
        let handLandmarker = undefined;
        let lastVideoTime = -1;

        async function initMediaPipe() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
                );
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').style.display = 'none', 800);
                
                startCamera();
            } catch (e) {
                console.error(e);
                statusText.innerText = "Error Loading AI";
                statusDot.classList.add('error');
            }
        }

        function startCamera() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                statusText.innerText = "Cam Not Supported";
                return;
            }

            navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } })
                .then((stream) => {
                    video.srcObject = stream;
                    video.addEventListener("loadeddata", () => {
                        state.cameraActive = true;
                        video.play();
                        statusText.innerText = "Tracking Active";
                        statusDot.classList.add('active');
                        document.getElementById('video-preview').style.display = 'block';
                    });
                })
                .catch((err) => {
                    console.warn(err);
                    statusText.innerText = "Cam Permission Denied";
                    statusDot.classList.add('error');
                });
        }

        function detectGestures(landmarks) {
            // Landmarks: 0=Wrist, 4=ThumbTip, 8=IndexTip, 12=MidTip, 16=RingTip, 20=PinkyTip
            // Knuckles: 5, 9, 13, 17
            
            const lm = landmarks[0];
            
            // Helper: Check if finger is extended (Tip above PIP joint - assuming hand is upright)
            // Note: MediaPipe Y coordinates: 0 is top, 1 is bottom. So Tip < PIP means extended UP.
            
            // Normalize for hand rotation? For simplicity, we assume upright hand mostly.
            // Better approach: Distance from wrist.
            
            const wrist = lm[0];
            
            function isExtended(tipIdx, pipIdx) {
                // Calculate distance from wrist
                const dTip = Math.hypot(lm[tipIdx].x - wrist.x, lm[tipIdx].y - wrist.y);
                const dPip = Math.hypot(lm[pipIdx].x - wrist.x, lm[pipIdx].y - wrist.y);
                return dTip > dPip; // If tip is further from wrist than knuckle
            }
            
            const thumbOpen = isExtended(4, 2);
            const indexOpen = isExtended(8, 6);
            const midOpen = isExtended(12, 10);
            const ringOpen = isExtended(16, 14);
            const pinkyOpen = isExtended(20, 18);
            
            const openFingersCount = [indexOpen, midOpen, ringOpen, pinkyOpen].filter(Boolean).length;
            const allOpen = openFingersCount === 4 && thumbOpen;
            const allClosed = openFingersCount === 0 && !thumbOpen;
            
            // Logic Tree
            if (allClosed) return 'Fist'; // Heart
            if (allOpen) return 'Open'; // Explode
            if (indexOpen && midOpen && !ringOpen && !pinkyOpen) return 'Victory'; // Star
            if (indexOpen && pinkyOpen && !midOpen && !ringOpen) return 'Rock'; // Note
            if (openFingersCount === 4 && !thumbOpen) return 'PalmThumbIn'; // LOVE
            
            return 'Unknown';
        }

        async function predictWebcam() {
            if (!handLandmarker || !state.cameraActive) return;
            
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, performance.now());
                
                if (results.landmarks && results.landmarks.length > 0) {
                    const gesture = detectGestures(results.landmarks);
                    if (gesture !== state.gesture) {
                        state.gesture = gesture;
                        handleGestureChange(gesture);
                    }
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function handleGestureChange(gesture) {
            statusText.innerText = `Detected: ${gesture}`;
            
            // Breathing animation speed reset
            
            switch(gesture) {
                case 'Fist':
                    state.isExploding = false;
                    updateTargets('heart');
                    break;
                case 'Open':
                    state.isExploding = true;
                    // Reset positions slightly to center to make explosion look fresh? 
                    // No, let them explode from where they are.
                    break;
                case 'Victory':
                    state.isExploding = false;
                    updateTargets('star');
                    break;
                case 'Rock':
                    state.isExploding = false;
                    updateTargets('note');
                    break;
                case 'PalmThumbIn':
                    state.isExploding = false;
                    updateTargets('love');
                    break;
                default:
                    // Keep previous state
                    break;
            }
        }


        // --- Main Loop ---

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            state.time += dt;
            material.uniforms.uTime.value = state.time;

            // Rotate Shape slowly
            if (!state.isExploding && state.targetShape !== 'sphere') {
               // Apply a global rotation to the container logic if we wanted, 
               // but since we calculate points, let's rotate the particle system or camera
               // Let's rotate the particle system container lightly
               particles.rotation.y = Math.sin(state.time * 0.2) * 0.2;
            }

            // Animate Particles
            animateParticles();

            // Render
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Init ---
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.uPixelRatio.value = renderer.getPixelRatio();
        });

        document.getElementById('toggle-cam').addEventListener('click', () => {
            if (state.cameraActive) {
                // Stop tracks
                const stream = video.srcObject;
                if(stream) {
                    const tracks = stream.getTracks();
                    tracks.forEach(track => track.stop());
                }
                video.srcObject = null;
                state.cameraActive = false;
                statusText.innerText = "Camera Paused";
                statusDot.classList.remove('active');
            } else {
                startCamera();
                predictWebcam();
            }
        });

        // Start everything
        initMediaPipe();
        animate();
        predictWebcam(); // Start prediction loop (will wait for cam)

    </script>
</body>
</html>
