<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿æ§åˆ¶ç²’å­ç‰¹æ•ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #video {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            border: 2px solid #00ffff;
            border-radius: 8px;
            display: none;
            z-index: 10;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .btn {
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            text-shadow: 0 0 10px #00ffff;
            backdrop-filter: blur(10px);
        }
        .btn:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 20px #00ffff;
        }
        .btn.active {
            background: rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 30px #00ffff;
        }
        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 24px;
            text-align: center;
            z-index: 1000;
        }
        .spinner {
            border: 4px solid rgba(0, 255, 255, 0.3);
            border-top: 4px solid #00ffff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #shape-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff00ff;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 20px #ff00ff;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 50;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <video id="video" autoplay playsinline></video>
    <div id="controls">
        <button id="toggleCamera" class="btn">å¼€å¯æ‘„åƒå¤´</button>
        <div style="color: #00ffff; font-size: 12px; text-shadow: 0 0 5px #00ffff;">
            ğŸ‘Š æ¡æ‹³ï¼šæ˜¾ç¤ºå½¢çŠ¶<br>
            âœ‹ å¼ å¼€ï¼šç²’å­æ•£å¼€<br>
            ğŸ‘ˆğŸ‘‰ å·¦å³æŒ¥ï¼šåˆ‡æ¢å½¢çŠ¶
        </div>
    </div>
    <div id="status">å‡†å¤‡å°±ç»ª</div>
    <div id="loading">
        <div class="spinner"></div>
        åŠ è½½ä¸­...
    </div>
    <div id="shape-indicator"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, particles, particleSystem;
        let cameraActive = false;
        let hands, videoCamera;
        let currentGesture = 'open'; // 'closed', 'open', 'left', 'right'
        let currentShapeIndex = 0;
        let lastSwipeTime = 0;
        let lastHandX = 0;
        let particleCount = 10000;
        let shockwaveTime = 0;
        
        const shapes = [
            { name: 'â¤ï¸ çˆ±å¿ƒ', type: 'heart' },
            { name: 'ğŸŒ¸ æ¨±èŠ±', type: 'flower' },
            { name: 'â­ äº”è§’æ˜Ÿ', type: 'star' },
            { name: 'â™« éŸ³ç¬¦', type: 'note' },
            { name: 'LOVE', type: 'love' }
        ];

        // é¡¶ç‚¹ç€è‰²å™¨
        const vertexShader = `
            attribute float size;
            attribute vec3 color;
            attribute float alpha;
            varying vec3 vColor;
            varying float vAlpha;
            
            void main() {
                vColor = color;
                vAlpha = alpha;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        // ç‰‡æ®µç€è‰²å™¨
        const fragmentShader = `
            varying vec3 vColor;
            varying float vAlpha;
            
            void main() {
                vec2 center = gl_PointCoord - vec2(0.5);
                float dist = length(center);
                
                // åˆ›å»ºæŸ”å…‰æ•ˆæœ
                float strength = 1.0 - smoothstep(0.0, 0.5, dist);
                float glow = 1.0 - smoothstep(0.0, 0.7, dist);
                
                vec3 finalColor = vColor * (strength + glow * 0.5);
                float finalAlpha = vAlpha * strength;
                
                gl_FragColor = vec4(finalColor, finalAlpha);
            }
        `;

        // åˆå§‹åŒ–åœºæ™¯
        function initScene() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 300;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 1);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // æ·»åŠ æ˜Ÿç©ºèƒŒæ™¯
            createStarfield();
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleSystem();
            
            document.getElementById('loading').style.display = 'none';
        }

        // åˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯
        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 2000;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 1000 - 500;
                
                const brightness = Math.random() * 0.5 + 0.5;
                colors[i * 3] = brightness;
                colors[i * 3 + 1] = brightness;
                colors[i * 3 + 2] = brightness;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            const starfield = new THREE.Points(starGeometry, starMaterial);
            scene.add(starfield);
        }

        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            
            const positions = new Float32Array(particleCount * 3);
            const targetPositions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const colors = new Float32Array(particleCount * 3);
            const alphas = new Float32Array(particleCount);
            
            // åˆå§‹åŒ–ç²’å­ä¸ºæ•£å¼€çŠ¶æ€
            for (let i = 0; i < particleCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = Math.random() * 400 + 200;
                
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
                
                targetPositions[i * 3] = positions[i * 3];
                targetPositions[i * 3 + 1] = positions[i * 3 + 1];
                targetPositions[i * 3 + 2] = positions[i * 3 + 2];
                
                velocities[i * 3] = (Math.random() - 0.5) * 2;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 2;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;
                
                sizes[i] = Math.random() * 8 + 2;
                
                const hue = Math.random();
                const color = new THREE.Color().setHSL(hue, 1, 0.6);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
                
                alphas[i] = Math.random() * 0.5 + 0.5;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
            
            particles = {
                positions,
                targetPositions,
                velocities,
                sizes,
                colors,
                alphas
            };
            
            const material = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        // ç”Ÿæˆçˆ±å¿ƒå½¢çŠ¶ç‚¹äº‘
        function createHeartPoints() {
            const points = [];
            const scale = 60;
            
            for (let i = 0; i < particleCount; i++) {
                const t = (i / particleCount) * Math.PI * 2;
                const u = Math.random() * Math.PI * 2;
                const r = Math.random() * 0.5 + 0.5;
                
                const x = r * scale * (16 * Math.pow(Math.sin(t), 3));
                const y = r * scale * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                const z = (Math.random() - 0.5) * 30 * r;
                
                points.push({ x, y: y - 20, z });
            }
            
            return points;
        }

        // ç”Ÿæˆæ¨±èŠ±å½¢çŠ¶ç‚¹äº‘
        function createFlowerPoints() {
            const points = [];
            const scale = 80;
            
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 10;
                const petalIndex = Math.floor(Math.random() * 5);
                const petalAngle = (petalIndex / 5) * Math.PI * 2;
                const r = (Math.random() * 0.7 + 0.3) * scale;
                const petalR = Math.sin((angle % (Math.PI * 2)) * 2.5) * 0.5 + 0.5;
                
                const x = r * petalR * Math.cos(angle + petalAngle);
                const y = r * petalR * Math.sin(angle + petalAngle);
                const z = (Math.random() - 0.5) * 20;
                
                points.push({ x, y, z });
            }
            
            return points;
        }

        // ç”Ÿæˆäº”è§’æ˜Ÿå½¢çŠ¶ç‚¹äº‘
        function createStarPoints() {
            const points = [];
            const scale = 100;
            
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2 * 5;
                const pointIndex = Math.floor((i / particleCount) * 10);
                const isOuter = pointIndex % 2 === 0;
                const r = (isOuter ? 1 : 0.4) * scale * (Math.random() * 0.3 + 0.7);
                const a = (pointIndex / 10) * Math.PI * 2;
                
                const x = r * Math.cos(a);
                const y = r * Math.sin(a);
                const z = (Math.random() - 0.5) * 30;
                
                points.push({ x, y, z });
            }
            
            return points;
        }

        // ç”ŸæˆéŸ³ç¬¦å½¢çŠ¶ç‚¹äº‘
        function createNotePoints() {
            const points = [];
            const scale = 80;
            
            for (let i = 0; i < particleCount; i++) {
                const t = i / particleCount;
                
                if (t < 0.3) {
                    // éŸ³ç¬¦å¤´ï¼ˆåœ†å½¢ï¼‰
                    const angle = (t / 0.3) * Math.PI * 2;
                    const r = Math.random() * 30;
                    const x = r * Math.cos(angle) - 40;
                    const y = r * Math.sin(angle) - 50;
                    const z = (Math.random() - 0.5) * 20;
                    points.push({ x, y, z });
                } else {
                    // éŸ³ç¬¦æ†
                    const x = -40 + (Math.random() - 0.5) * 10;
                    const y = -50 + ((t - 0.3) / 0.7) * 120;
                    const z = (Math.random() - 0.5) * 20;
                    points.push({ x, y, z });
                }
            }
            
            return points;
        }

        // ç”ŸæˆLOVEæ–‡å­—ç‚¹äº‘
        function createLovePoints() {
            const points = [];
            const letters = [
                // L
                [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [2, 0]],
                // O
                [[0, 0], [1, 0], [2, 0], [0, 1], [2, 1], [0, 2], [2, 2], [0, 3], [2, 3], [0, 4], [1, 4], [2, 4]],
                // V
                [[0, 4], [0, 3], [0, 2], [1, 1], [1, 0], [2, 1], [2, 2], [2, 3], [2, 4]],
                // E
                [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [2, 0], [1, 2], [1, 4], [2, 4]]
            ];
            
            const letterSpacing = 50;
            const scale = 15;
            const pointsPerCell = Math.floor(particleCount / (letters[0].length + letters[1].length + letters[2].length + letters[3].length));
            
            letters.forEach((letter, letterIndex) => {
                letter.forEach(([x, y]) => {
                    for (let i = 0; i < pointsPerCell; i++) {
                        points.push({
                            x: (x * scale + letterIndex * letterSpacing - 75) + (Math.random() - 0.5) * scale * 0.5,
                            y: (y * scale - 30) + (Math.random() - 0.5) * scale * 0.5,
                            z: (Math.random() - 0.5) * 15
                        });
                    }
                });
            });
            
            // å¡«å……å‰©ä½™ç²’å­
            while (points.length < particleCount) {
                const randLetter = letters[Math.floor(Math.random() * letters.length)];
                const randCell = randLetter[Math.floor(Math.random() * randLetter.length)];
                const letterIndex = letters.indexOf(randLetter);
                points.push({
                    x: (randCell[0] * scale + letterIndex * letterSpacing - 75) + (Math.random() - 0.5) * scale,
                    y: (randCell[1] * scale - 30) + (Math.random() - 0.5) * scale,
                    z: (Math.random() - 0.5) * 15
                });
            }
            
            return points;
        }

        // æ›´æ–°ç²’å­ç›®æ ‡ä½ç½®
        function updateParticleTargets(mode) {
            let targetPoints;
            
            if (mode === 'scattered') {
                // æ•£å¼€æ¨¡å¼
                for (let i = 0; i < particleCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const radius = Math.random() * 400 + 200;
                    
                    particles.targetPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    particles.targetPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    particles.targetPositions[i * 3 + 2] = radius * Math.cos(phi);
                    
                    // è®¾ç½®é€Ÿåº¦
                    const dx = particles.targetPositions[i * 3] - particles.positions[i * 3];
                    const dy = particles.targetPositions[i * 3 + 1] - particles.positions[i * 3 + 1];
                    const dz = particles.targetPositions[i * 3 + 2] - particles.positions[i * 3 + 2];
                    
                    particles.velocities[i * 3] = dx * 0.05;
                    particles.velocities[i * 3 + 1] = dy * 0.05;
                    particles.velocities[i * 3 + 2] = dz * 0.05;
                }
                
                // è§¦å‘å†²å‡»æ³¢æ•ˆæœ
                shockwaveTime = 1.0;
                
            } else {
                // å½¢çŠ¶æ¨¡å¼
                const shapeType = shapes[currentShapeIndex].type;
                
                switch (shapeType) {
                    case 'heart':
                        targetPoints = createHeartPoints();
                        break;
                    case 'flower':
                        targetPoints = createFlowerPoints();
                        break;
                    case 'star':
                        targetPoints = createStarPoints();
                        break;
                    case 'note':
                        targetPoints = createNotePoints();
                        break;
                    case 'love':
                        targetPoints = createLovePoints();
                        break;
                }
                
                for (let i = 0; i < particleCount; i++) {
                    const point = targetPoints[i];
                    particles.targetPositions[i * 3] = point.x;
                    particles.targetPositions[i * 3 + 1] = point.y;
                    particles.targetPositions[i * 3 + 2] = point.z;
                }
            }
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // æ›´æ–°ç²’å­ä½ç½®
            for (let i = 0; i < particleCount; i++) {
                const idx = i * 3;
                
                // è®¡ç®—åˆ°ç›®æ ‡çš„è·ç¦»
                const dx = particles.targetPositions[idx] - particles.positions[idx];
                const dy = particles.targetPositions[idx + 1] - particles.positions[idx + 1];
                const dz = particles.targetPositions[idx + 2] - particles.positions[idx + 2];
                
                // ç¼“åŠ¨æ’å€¼
                const damping = currentGesture === 'open' ? 0.05 : 0.08;
                particles.positions[idx] += dx * damping + particles.velocities[idx] * 0.1;
                particles.positions[idx + 1] += dy * damping + particles.velocities[idx + 1] * 0.1;
                particles.positions[idx + 2] += dz * damping + particles.velocities[idx + 2] * 0.1;
                
                // æ›´æ–°é€Ÿåº¦ï¼ˆæ·»åŠ ä¸€äº›éšæœºæ€§å’Œé˜»å°¼ï¼‰
                particles.velocities[idx] *= 0.95;
                particles.velocities[idx + 1] *= 0.95;
                particles.velocities[idx + 2] *= 0.95;
                
                if (currentGesture === 'open') {
                    particles.velocities[idx] += (Math.random() - 0.5) * 0.5;
                    particles.velocities[idx + 1] += (Math.random() - 0.5) * 0.5;
                    particles.velocities[idx + 2] += (Math.random() - 0.5) * 0.5;
                }
                
                // æ›´æ–°é¢œè‰²
                const speed = Math.sqrt(
                    particles.velocities[idx] ** 2 + 
                    particles.velocities[idx + 1] ** 2 + 
                    particles.velocities[idx + 2] ** 2
                );
                
                if (currentGesture === 'open') {
                    const hue = (i / particleCount + time * 0.1) % 1;
                    const color = new THREE.Color().setHSL(hue, 1, 0.6);
                    particles.colors[idx] = color.r;
                    particles.colors[idx + 1] = color.g;
                    particles.colors[idx + 2] = color.b;
                } else {
                    // å½¢çŠ¶æ¨¡å¼ï¼šç²‰ç´«/é‡‘è‰²æ¸å˜
                    const t = i / particleCount;
                    const color = new THREE.Color().setHSL(0.85 - t * 0.15, 0.8, 0.6);
                    particles.colors[idx] = color.r;
                    particles.colors[idx + 1] = color.g;
                    particles.colors[idx + 2] = color.b;
                }
            }
            
            // æ›´æ–°å‡ ä½•ä½“
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
            
            // æ·»åŠ å‘¼å¸å’Œæ—‹è½¬åŠ¨ç”»ï¼ˆä»…åœ¨å½¢çŠ¶æ¨¡å¼ä¸‹ï¼‰
            if (currentGesture === 'closed') {
                const breathe = Math.sin(time * 2) * 0.05 + 1;
                particleSystem.scale.set(breathe, breathe, breathe);
                particleSystem.rotation.z = Math.sin(time * 0.5) * 0.1;
            } else {
                particleSystem.scale.set(1, 1, 1);
                particleSystem.rotation.z = 0;
            }
            
            // å†²å‡»æ³¢æ•ˆæœè¡°å‡
            if (shockwaveTime > 0) {
                shockwaveTime -= 0.02;
            }
            
            renderer.render(scene, camera);
        }

        // åˆå§‹åŒ–MediaPipe Hands
        function initMediaPipe() {
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            
            hands.onResults(onHandsResults);
        }

        // æ‰‹åŠ¿è¯†åˆ«å›è°ƒ
        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // æ£€æµ‹æ¡æ‹³ï¼šæ‰€æœ‰æ‰‹æŒ‡å°–éƒ½æ¥è¿‘æ‰‹æŒ
                const isFist = checkFist(landmarks);
                
                // æ£€æµ‹å¼ å¼€æ‰‹æŒï¼šæ‰€æœ‰æ‰‹æŒ‡éƒ½ä¼¸å±•å¼€
                const isOpen = checkOpenPalm(landmarks);
                
                // æ£€æµ‹å·¦å³æŒ¥åŠ¨
                const handX = landmarks[9].x; // ä½¿ç”¨ä¸­æŒ‡æ ¹éƒ¨çš„xåæ ‡
                const swipeThreshold = 0.15;
                const currentTime = Date.now();
                
                if (currentTime - lastSwipeTime > 800) {
                    if (handX - lastHandX > swipeThreshold) {
                        // å³æŒ¥
                        currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
                        showShapeIndicator();
                        updateParticleTargets('shape');
                        lastSwipeTime = currentTime;
                    } else if (lastHandX - handX > swipeThreshold) {
                        // å·¦æŒ¥
                        currentShapeIndex = (currentShapeIndex - 1 + shapes.length) % shapes.length;
                        showShapeIndicator();
                        updateParticleTargets('shape');
                        lastSwipeTime = currentTime;
                    }
                }
                
                lastHandX = handX;
                
                // æ›´æ–°æ‰‹åŠ¿çŠ¶æ€
                if (isFist && currentGesture !== 'closed') {
                    currentGesture = 'closed';
                    updateParticleTargets('shape');
                    updateStatus(`${shapes[currentShapeIndex].name}`);
                } else if (isOpen && currentGesture !== 'open') {
                    currentGesture = 'open';
                    updateParticleTargets('scattered');
                    updateStatus('ç²’å­æ•£å¼€');
                }
            }
        }

        // æ£€æµ‹æ¡æ‹³æ‰‹åŠ¿
        function checkFist(landmarks) {
            // æ£€æŸ¥æ‰€æœ‰æ‰‹æŒ‡å°–æ˜¯å¦æ¥è¿‘æ‰‹æŒä¸­å¿ƒ
            const palmCenter = landmarks[9]; // ä¸­æŒ‡æ ¹éƒ¨ä½œä¸ºæ‰‹æŒä¸­å¿ƒ
            const fingerTips = [4, 8, 12, 16, 20]; // æ‹‡æŒ‡ã€é£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡å°–
            
            let closedCount = 0;
            fingerTips.forEach(tipIndex => {
                const tip = landmarks[tipIndex];
                const distance = Math.sqrt(
                    (tip.x - palmCenter.x) ** 2 + 
                    (tip.y - palmCenter.y) ** 2
                );
                if (distance < 0.15) closedCount++;
            });
            
            return closedCount >= 4;
        }

        // æ£€æµ‹å¼ å¼€æ‰‹æŒ
        function checkOpenPalm(landmarks) {
            const palmCenter = landmarks[9];
            const fingerTips = [4, 8, 12, 16, 20];
            
            let openCount = 0;
            fingerTips.forEach(tipIndex => {
                const tip = landmarks[tipIndex];
                const distance = Math.sqrt(
                    (tip.x - palmCenter.x) ** 2 + 
                    (tip.y - palmCenter.y) ** 2
                );
                if (distance > 0.2) openCount++;
            });
            
            return openCount >= 4;
        }

        // æ˜¾ç¤ºå½¢çŠ¶æŒ‡ç¤ºå™¨
        function showShapeIndicator() {
            const indicator = document.getElementById('shape-indicator');
            indicator.textContent = shapes[currentShapeIndex].name;
            indicator.style.opacity = '1';
            
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 1500);
        }

        // æ›´æ–°çŠ¶æ€æ–‡æœ¬
        function updateStatus(text) {
            document.getElementById('status').textContent = text;
        }

        // åˆ‡æ¢æ‘„åƒå¤´
        async function toggleCamera() {
            const btn = document.getElementById('toggleCamera');
            const video = document.getElementById('video');
            
            if (!cameraActive) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'user' },
                        audio: false 
                    });
                    
                    video.srcObject = stream;
                    video.style.display = 'block';
                    
                    videoCamera = new Camera(video, {
                        onFrame: async () => {
                            await hands.send({ image: video });
                        },
                        width: 640,
                        height: 480
                    });
                    
                    videoCamera.start();
                    
                    cameraActive = true;
                    btn.textContent = 'å…³é—­æ‘„åƒå¤´';
                    btn.classList.add('active');
                    updateStatus('æ‘„åƒå¤´å·²å¼€å¯');
                } catch (err) {
                    alert('æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼š' + err.message);
                }
            } else {
                if (videoCamera) {
                    videoCamera.stop();
                }
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                }
                video.style.display = 'none';
                cameraActive = false;
                btn.textContent = 'å¼€å¯æ‘„åƒå¤´';
                btn.classList.remove('active');
                updateStatus('æ‘„åƒå¤´å·²å…³é—­');
            }
        }

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // åˆå§‹åŒ–
        initScene();
        initMediaPipe();
        animate();
        
        // ç»‘å®šæŒ‰é’®äº‹ä»¶
        document.getElementById('toggleCamera').addEventListener('click', toggleCamera);
    </script>
</body>
</html>