<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿ç²’å­é­”æ³• | Gesture Particle Magic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #0d0d1a 0%, #000000 100%);
            font-family: 'Arial', sans-serif;
        }
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #video {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            transform: scaleX(-1);
            display: none;
            z-index: 10;
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }
        .loader {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #ff00ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #loading-text {
            font-size: 18px;
            color: #fff;
            text-align: center;
            padding: 0 20px;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
        }
        .control-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        #gesture-hint {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 100, 255, 0.5);
            border-radius: 20px;
            color: white;
            font-size: 16px;
            z-index: 100;
            backdrop-filter: blur(10px);
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <video id="video" autoplay playsinline></video>
    
    <div id="loading">
        <div class="loader"></div>
        <div id="loading-text">æ­£åœ¨åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ...</div>
    </div>
    
    <div id="controls">
        <button class="control-btn" id="toggle-camera">å…³é—­æ‘„åƒå¤´</button>
        <button class="control-btn" id="toggle-video">æ˜¾ç¤ºè§†é¢‘</button>
    </div>
    
    <div id="gesture-hint">ğŸ‘‹ ç­‰å¾…æ£€æµ‹æ‰‹åŠ¿...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <script>
        // ========== å…¨å±€å˜é‡ ==========
        let scene, camera, renderer, particles, particleSystem;
        let targetPositions = [];
        let currentShape = 'scatter';
        let hands, videoElement, cameraActive = true;
        const PARTICLE_COUNT = 10000;
        let shockwaveUniforms;

        // ========== åˆå§‹åŒ– Three.js ==========
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // æ·»åŠ æ˜Ÿç©ºèƒŒæ™¯
            createStarfield();
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleSystem();

            // åˆ›å»ºå†²å‡»æ³¢æ•ˆæœ
            createShockwave();

            window.addEventListener('resize', onWindowResize);
        }

        // ========== æ˜Ÿç©ºèƒŒæ™¯ ==========
        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const starPositions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                starPositions[i] = (Math.random() - 0.5) * 200;
                starPositions[i + 1] = (Math.random() - 0.5) * 200;
                starPositions[i + 2] = (Math.random() - 0.5) * 200;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.6
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        // ========== ç²’å­ç³»ç»Ÿ ==========
        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const velocities = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);
            
            // åˆå§‹åŒ–ä¸ºæ•£å¼€çŠ¶æ€
            for (let i = 0; i < PARTICLE_COUNT * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 100;
                positions[i + 1] = (Math.random() - 0.5) * 100;
                positions[i + 2] = (Math.random() - 0.5) * 50;
                
                velocities[i] = (Math.random() - 0.5) * 0.2;
                velocities[i + 1] = (Math.random() - 0.5) * 0.2;
                velocities[i + 2] = (Math.random() - 0.5) * 0.2;
                
                const color = new THREE.Color();
                color.setHSL(Math.random(), 1.0, 0.6);
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
                
                sizes[i / 3] = Math.random() * 2 + 1;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // è‡ªå®šä¹‰ç€è‰²å™¨
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    breathe: { value: 1.0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    uniform float breathe;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * breathe * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        
                        if (dist > 0.5) discard;
                        
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        float glow = pow(alpha, 2.0);
                        
                        vec3 finalColor = vColor * (0.5 + glow * 0.5);
                        gl_FragColor = vec4(finalColor, alpha * 0.9);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                vertexColors: true
            });
            
            particles = geometry;
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // åˆå§‹åŒ–ç›®æ ‡ä½ç½®
            targetPositions = createScatterPoints();
        }

        // ========== å†²å‡»æ³¢æ•ˆæœ ==========
        function createShockwave() {
            const geometry = new THREE.RingGeometry(0.1, 0.2, 64);
            shockwaveUniforms = {
                time: { value: 0 },
                opacity: { value: 0 }
            };
            
            const material = new THREE.ShaderMaterial({
                uniforms: shockwaveUniforms,
                vertexShader: `
                    uniform float time;
                    void main() {
                        vec3 pos = position * (1.0 + time * 50.0);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float opacity;
                    void main() {
                        gl_FragColor = vec4(1.0, 0.3, 1.0, opacity);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            
            const shockwave = new THREE.Mesh(geometry, material);
            scene.add(shockwave);
        }

        // ========== å½¢çŠ¶ç”Ÿæˆå‡½æ•° ==========
        function createHeartPoints() {
            const points = [];
            const scale = 8;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                const layers = Math.floor(i / (PARTICLE_COUNT / 20));
                const z = (Math.random() - 0.5) * 5;
                
                const x = scale * 16 * Math.pow(Math.sin(t), 3);
                const y = scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                
                points.push(new THREE.Vector3(x, y - 10, z));
            }
            return points;
        }

        function createFlowerPoints() {
            const points = [];
            const petalCount = 5;
            const scale = 15;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const angle = (i / PARTICLE_COUNT) * Math.PI * 2 * petalCount;
                const r = scale * (1 + 0.5 * Math.sin(petalCount * angle));
                const theta = angle;
                
                const x = r * Math.cos(theta);
                const y = r * Math.sin(theta);
                const z = (Math.random() - 0.5) * 3;
                
                points.push(new THREE.Vector3(x, y, z));
            }
            return points;
        }

        function createStarPoints() {
            const points = [];
            const outerRadius = 20;
            const innerRadius = 8;
            const spikes = 5;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const angle = (i / PARTICLE_COUNT) * Math.PI * 2;
                const spikeAngle = (Math.PI * 2) / spikes;
                const spikeIndex = Math.floor(angle / spikeAngle);
                const angleInSpike = angle % spikeAngle;
                
                let radius;
                if (angleInSpike < spikeAngle / 2) {
                    radius = innerRadius + (outerRadius - innerRadius) * (angleInSpike / (spikeAngle / 2));
                } else {
                    radius = outerRadius - (outerRadius - innerRadius) * ((angleInSpike - spikeAngle / 2) / (spikeAngle / 2));
                }
                
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                const z = (Math.random() - 0.5) * 4;
                
                points.push(new THREE.Vector3(x, y, z));
            }
            return points;
        }

        function createMusicNotePoints() {
            const points = [];
            const scale = 15;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = i / PARTICLE_COUNT;
                
                if (t < 0.3) {
                    // éŸ³ç¬¦å¤´ï¼ˆåœ†å½¢ï¼‰
                    const angle = (t / 0.3) * Math.PI * 2;
                    const r = scale * 0.4;
                    const x = r * Math.cos(angle) - scale;
                    const y = r * Math.sin(angle) - scale;
                    const z = (Math.random() - 0.5) * 2;
                    points.push(new THREE.Vector3(x, y, z));
                } else {
                    // éŸ³ç¬¦æ†
                    const progress = (t - 0.3) / 0.7;
                    const x = -scale + Math.sin(progress * Math.PI) * 2;
                    const y = -scale + progress * scale * 2.5;
                    const z = (Math.random() - 0.5) * 2;
                    points.push(new THREE.Vector3(x, y, z));
                }
            }
            return points;
        }

        function createLoveTextPoints() {
            const points = [];
            const letters = ['L', 'O', 'V', 'E'];
            const letterSpacing = 12;
            const startX = -letterSpacing * 1.5;
            
            for (let l = 0; l < letters.length; l++) {
                const letterPoints = getLetterPoints(letters[l]);
                const offsetX = startX + l * letterSpacing;
                
                for (let i = 0; i < PARTICLE_COUNT / 4; i++) {
                    const point = letterPoints[i % letterPoints.length];
                    points.push(new THREE.Vector3(
                        point.x + offsetX,
                        point.y,
                        (Math.random() - 0.5) * 3
                    ));
                }
            }
            
            return points;
        }

        function getLetterPoints(letter) {
            const points = [];
            const scale = 8;
            
            switch(letter) {
                case 'L':
                    for (let i = 0; i < 50; i++) {
                        points.push(new THREE.Vector3(-scale/2, -scale + i * scale * 2 / 50, 0));
                        if (i < 25) points.push(new THREE.Vector3(-scale/2 + i * scale / 25, -scale, 0));
                    }
                    break;
                case 'O':
                    for (let i = 0; i < 50; i++) {
                        const angle = (i / 50) * Math.PI * 2;
                        points.push(new THREE.Vector3(
                            scale/2 * Math.cos(angle),
                            scale * Math.sin(angle),
                            0
                        ));
                    }
                    break;
                case 'V':
                    for (let i = 0; i < 50; i++) {
                        if (i < 25) {
                            points.push(new THREE.Vector3(-scale/2 + i * scale / 50, scale - i * scale * 2 / 25, 0));
                        } else {
                            const j = i - 25;
                            points.push(new THREE.Vector3(j * scale / 50, -scale + j * scale * 2 / 25, 0));
                        }
                    }
                    break;
                case 'E':
                    for (let i = 0; i < 50; i++) {
                        points.push(new THREE.Vector3(-scale/2, -scale + i * scale * 2 / 50, 0));
                        if (i < 17) points.push(new THREE.Vector3(-scale/2 + i * scale / 17, scale, 0));
                        if (i < 17) points.push(new THREE.Vector3(-scale/2 + i * scale / 17, 0, 0));
                        if (i < 17) points.push(new THREE.Vector3(-scale/2 + i * scale / 17, -scale, 0));
                    }
                    break;
            }
            
            return points;
        }

        function createScatterPoints() {
            const points = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                points.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 50
                ));
            }
            return points;
        }

        // ========== æ‰‹åŠ¿è¯†åˆ« ==========
        function detectGesture(landmarks) {
            if (!landmarks || landmarks.length === 0) return 'none';
            
            const fingers = {
                thumb: isFingerExtended(landmarks, 4, 3, 2),
                index: isFingerExtended(landmarks, 8, 7, 6),
                middle: isFingerExtended(landmarks, 12, 11, 10),
                ring: isFingerExtended(landmarks, 16, 15, 14),
                pinky: isFingerExtended(landmarks, 20, 19, 18)
            };
            
            const extendedCount = Object.values(fingers).filter(v => v).length;
            
            // å®Œå…¨å¼ å¼€æ‰‹æŒ
            if (extendedCount === 5) {
                return 'open';
            }
            
            // æ¡æ‹³
            if (extendedCount === 0) {
                return 'fist';
            }
            
            // Væ‰‹åŠ¿ (é£ŸæŒ‡+ä¸­æŒ‡)
            if (fingers.index && fingers.middle && !fingers.ring && !fingers.pinky) {
                return 'peace';
            }
            
            // æ‘‡æ»šæ‰‹åŠ¿ (é£ŸæŒ‡+å°æ‹‡æŒ‡+å¤§æ‹‡æŒ‡)
            if (fingers.thumb && fingers.index && fingers.pinky && !fingers.middle && !fingers.ring) {
                return 'rock';
            }
            
            // LOVEæ‰‹åŠ¿ (å¤§æ‹‡æŒ‡å†…æ‰£ï¼Œå…¶ä»–ä¼¸å‡º)
            if (!fingers.thumb && fingers.index && fingers.middle && fingers.ring && fingers.pinky) {
                return 'love';
            }
            
            return 'none';
        }

        function isFingerExtended(landmarks, tip, mid, base) {
            const tipY = landmarks[tip].y;
            const midY = landmarks[mid].y;
            const baseY = landmarks[base].y;
            
            return tipY < midY && midY < baseY;
        }

        // ========== MediaPipe åˆå§‹åŒ– ==========
        async function initMediaPipe() {
            videoElement = document.getElementById('video');
            
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            
            hands.onResults(onHandsResults);
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'user',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    } 
                });
                videoElement.srcObject = stream;
                
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        if (cameraActive) {
                            await hands.send({ image: videoElement });
                        }
                    },
                    width: 640,
                    height: 480
                });
                camera.start();
                
                document.getElementById('loading-text').textContent = 'åˆå§‹åŒ–å®Œæˆï¼';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('gesture-hint').style.display = 'block';
                }, 500);
                
            } catch (error) {
                console.error('æ‘„åƒå¤´è®¿é—®å¤±è´¥:', error);
                document.getElementById('loading-text').textContent = 'æ‘„åƒå¤´è®¿é—®å¤±è´¥ï¼Œå°†ä½¿ç”¨éšæœºåŠ¨ç”»æ¨¡å¼';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    startRandomMode();
                }, 2000);
            }
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const gesture = detectGesture(results.multiHandLandmarks[0]);
                updateGestureHint(gesture);
                
                if (gesture !== 'none' && gesture !== currentShape) {
                    transitionToShape(gesture);
                }
            }
        }

        function updateGestureHint(gesture) {
            const hintElement = document.getElementById('gesture-hint');
            const hints = {
                'fist': 'âœŠ æ¡æ‹³ â†’ çˆ±å¿ƒ',
                'open': 'ğŸ–ï¸ å¼ å¼€ â†’ ç²’å­æ•£å¼€',
                'peace': 'âœŒï¸ Væ‰‹åŠ¿ â†’ äº”è§’æ˜Ÿ',
                'rock': 'ğŸ¤˜ æ‘‡æ»š â†’ éŸ³ç¬¦',
                'love': 'ğŸ¤Ÿ LOVE â†’ æ–‡å­—',
                'none': 'ğŸ‘‹ ç­‰å¾…æ£€æµ‹æ‰‹åŠ¿...'
            };
            hintElement.textContent = hints[gesture] || hints['none'];
        }

        function transitionToShape(gesture) {
            currentShape = gesture;
            
            switch(gesture) {
                case 'fist':
                    targetPositions = createHeartPoints();
                    updateParticleColors([1.0, 0.2, 0.5]);
                    break;
                case 'open':
                    targetPositions = createScatterPoints();
                    updateParticleColors('rainbow');
                    triggerShockwave();
                    break;
                case 'peace':
                    targetPositions = createStarPoints();
                    updateParticleColors([1.0, 0.8, 0.0]);
                    break;
                case 'rock':
                    targetPositions = createMusicNotePoints();
                    updateParticleColors([0.5, 0.0, 1.0]);
                    break;
                case 'love':
                    targetPositions = createLoveTextPoints();
                    updateParticleColors([1.0, 0.0, 1.0]);
                    break;
            }
        }

        function updateParticleColors(colorData) {
            const colors = particles.attributes.color.array;
            
            for (let i = 0; i < colors.length; i += 3) {
                if (colorData === 'rainbow') {
                    const hue = Math.random();
                    const color = new THREE.Color().setHSL(hue, 1.0, 0.6);
                    colors[i] = color.r;
                    colors[i + 1] = color.g;
                    colors[i + 2] = color.b;
                } else {
                    colors[i] = colorData[0] + (Math.random() - 0.5) * 0.2;
                    colors[i + 1] = colorData[1] + (Math.random() - 0.5) * 0.2;
                    colors[i + 2] = colorData[2] + (Math.random() - 0.5) * 0.2;
                }
            }
            
            particles.attributes.color.needsUpdate = true;
        }

        function triggerShockwave() {
            shockwaveUniforms.time.value = 0;
            shockwaveUniforms.opacity.value = 1.0;
        }

        // ========== åŠ¨ç”»å¾ªç¯ ==========
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.01;
            
            // æ›´æ–°ç²’å­ä½ç½®
            const positions = particles.attributes.position.array;
            const velocities = particles.attributes.velocity.array;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const target = targetPositions[i];
                
                // è®¡ç®—å¸å¼•åŠ›
                const dx = target.x - positions[i3];
                const dy = target.y - positions[i3 + 1];
                const dz = target.z - positions[i3 + 2];
                
                const force = currentShape === 'open' ? 0.001 : 0.05;
                
                velocities[i3] += dx * force;
                velocities[i3 + 1] += dy * force;
                velocities[i3 + 2] += dz * force;
                
                // åº”ç”¨é˜»å°¼
                const damping = currentShape === 'open' ? 0.95 : 0.85;
                velocities[i3] *= damping;
                velocities[i3 + 1] *= damping;
                velocities[i3 + 2] *= damping;
                
                // æ›´æ–°ä½ç½®
                positions[i3] += velocities[i3];
                positions[i3 + 1] += velocities[i3 + 1];
                positions[i3 + 2] += velocities[i3 + 2];
            }
            
            particles.attributes.position.needsUpdate = true;
            
            // å‘¼å¸åŠ¨ç”»
            const breathe = 1.0 + Math.sin(time * 2) * 0.1;
            particleSystem.material.uniforms.breathe.value = breathe;
            particleSystem.material.uniforms.time.value = time;
            
            // æ—‹è½¬æ•ˆæœ
            if (currentShape !== 'open' && currentShape !== 'scatter') {
                particleSystem.rotation.z = Math.sin(time * 0.5) * 0.1;
            }
            
            // æ›´æ–°å†²å‡»æ³¢
            if (shockwaveUniforms.opacity.value > 0) {
                shockwaveUniforms.time.value += 0.02;
                shockwaveUniforms.opacity.value -= 0.02;
            }
            
            renderer.render(scene, camera);
        }

        // ========== éšæœºæ¨¡å¼ï¼ˆæ‘„åƒå¤´å¤±è´¥æ—¶çš„å¤‡é€‰æ–¹æ¡ˆï¼‰==========
        function startRandomMode() {
            const shapes = ['fist', 'peace', 'rock', 'love', 'open'];
            let currentIndex = 0;
            
            setInterval(() => {
                transitionToShape(shapes[currentIndex]);
                currentIndex = (currentIndex + 1) % shapes.length;
            }, 3000);
        }

        // ========== æ§åˆ¶æŒ‰é’® ==========
        document.getElementById('toggle-camera').addEventListener('click', function() {
            cameraActive = !cameraActive;
            this.textContent = cameraActive ? 'å…³é—­æ‘„åƒå¤´' : 'å¼€å¯æ‘„åƒå¤´';
        });

        document.getElementById('toggle-video').addEventListener('click', function() {
            const video = document.getElementById('video');
            if (video.style.display === 'none') {
                video.style.display = 'block';
                this.textContent = 'éšè—è§†é¢‘';
            } else {
                video.style.display = 'none';
                this.textContent = 'æ˜¾ç¤ºè§†é¢‘';
            }
        });

        // ========== çª—å£å¤§å°è°ƒæ•´ ==========
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ========== å¯åŠ¨ ==========
        initThree();
        initMediaPipe();
        animate();
    </script>
</body>
</html>
