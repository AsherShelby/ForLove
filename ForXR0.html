<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>⭐For XR0⭐</title>
    <style>
        :root {
            --primary: #00f3ff;
            --secondary: #bc13fe;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', sans-serif;
            color: white;
            user-select: none;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        .hud-text {
            text-shadow: 0 0 10px var(--primary);
            pointer-events: auto;
        }
        #status {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
        }
        #gesture-name {
            font-size: 32px;
            font-weight: bold;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 10px;
            transition: all 0.3s;
        }
        
        /* Loading Screen */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.8s ease;
        }
        .loader-ring {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(0, 243, 255, 0.2);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        #loader p {
            margin-top: 20px;
            color: var(--primary);
            font-size: 14px;
            letter-spacing: 1px;
        }
        #start-btn {
            margin-top: 30px;
            padding: 12px 30px;
            background: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s;
            display: none;
            pointer-events: auto;
        }
        #start-btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 20px var(--primary);
        }

        /* Controls */
        .controls {
            pointer-events: auto;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .btn-toggle {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: 0.3s;
        }
        .btn-toggle:hover {
            border-color: var(--primary);
            color: var(--primary);
        }
        .video-preview {
            width: 160px;
            height: 120px;
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            overflow: hidden;
            transform: scaleX(-1); /* Mirror */
            display: block;
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    
    <script type="importmap">
        {
           "imports": {
                "three": "https://cdn.staticfile.org/three.js/0.160.0/three.module.js",
                "@mediapipe/hands": "https://registry.npmmirror.com/@mediapipe/hands/0.4.1675469240/files/hands.js",
                "@mediapipe/drawing_utils": "https://registry.npmmirror.com/@mediapipe/drawing_utils/0.3.1620248257/files/drawing_utils.js"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="loader-ring"></div>
        <p id="loader-text">正在初始化...稍等噢~</p>
        <button id="start-btn">开始</button>
    </div>

    <div id="ui-layer">
        <div>
            <div id="status">WAITING FOR INPUT...</div>
            <div id="gesture-name">已经准备好咯~</div>
        </div>
        
        <div class="controls">
            <div class="video-preview" id="camera-container">
                <video id="input-video" playsinline></video>
            </div>
            <button class="btn-toggle" id="cam-toggle">TOGGLE CAM</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        // MediaPipe creates globals, we load the script dynamically to ensure order
    
        // ==========================================
        // CONFIGURATION
        // ==========================================
        const CONFIG = {
            particleCount: 16000,
            particleSize: 16.0, // Base size
            moveSpeed: 0.08,   // How fast particles fly to target (0-1)
            scatterForce: 0.9, // Friction/Damping
            colors: {
                scatter: new THREE.Color('#00f3ff'), // Cyan
                heart: new THREE.Color('#ff0055'),   // Pink/Red
                star: new THREE.Color('#ffe600'),    // Gold
                flower: new THREE.Color('#ff69b4'),  // HotPink
                note: new THREE.Color('#bc13fe'),    // Purple
                text: new THREE.Color('#ffffff')     // White
            }
        };

        // ==========================================
        // SHADERS (GLSL)
        // ==========================================
        const vertexShader = `
            uniform float uTime;
            uniform float uPixelRatio;
            uniform float uSize;
            
            attribute vec3 targetPosition;
            attribute float sizeRandom;
            attribute vec3 color;
            
            varying vec3 vColor;
            varying float vDistance;

            void main() {
                vColor = color;
                
                // Add some noise/float to position
                vec3 pos = position;
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                
                gl_Position = projectionMatrix * mvPosition;
                
                // Size attenuation based on depth
                gl_PointSize = uSize * sizeRandom * uPixelRatio * (300.0 / -mvPosition.z);
            }
        `;

        const fragmentShader = `
            uniform float uTime;
            varying vec3 vColor;

            void main() {
                // Create a soft glowing point sprite
                vec2 uv = gl_PointCoord.xy - 0.5;
                float dist = length(uv);
                
                // Circular gradient
                float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                
                // Make core brighter
                alpha = pow(alpha, 3.0);
                
                if (alpha < 0.01) discard;

                // Add inner glow
                vec3 finalColor = vColor * 1.5; 
                
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        // ==========================================
        // SYSTEM VARIABLES
        // ==========================================
        let scene, camera, renderer, material, geometry, points;
        let clock = new THREE.Clock();
        let mouse = new THREE.Vector2();
        
        // Particle Data
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const targets = new Float32Array(CONFIG.particleCount * 3);
        const velocities = new Float32Array(CONFIG.particleCount * 3); // For physics
        const colors = new Float32Array(CONFIG.particleCount * 3);
        const sizes = new Float32Array(CONFIG.particleCount);

        // State Management
        let currentShape = 'scatter'; // scatter, heart, star, flower, note, text
        let isHandDetected = false;
        let targetColor = new THREE.Color();
        let activeGestureTime = 0;

        // Pre-calculated shapes
        let shapeCache = {};

        // Canvas for text generation
        const textCanvas = document.createElement('canvas');
        const textCtx = textCanvas.getContext('2d');

        // ==========================================
        // SHAPE GENERATORS
        // ==========================================
        const ShapeUtils = {
            // Helper: Sphere distribution
            getSpherePoint: (r) => {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                return {x, y, z};
            },

            // 1. Heart (Parametric)
            createHeart: () => {
                const arr = [];
                for(let i=0; i<CONFIG.particleCount; i++) {
                    // Spread points nicely
                    let t = Math.random() * Math.PI * 2;
                    let u = Math.random(); 
                    
                    // Heart formula
                    let x = 16 * Math.pow(Math.sin(t), 3);
                    let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    let z = (Math.random() - 0.5) * 5; // Thickness
                    
                    // Fill inside slightly
                    const scale = 0.5 + Math.random() * 0.5;
                    x *= scale; y *= scale; z *= scale;

                    arr.push(x * 15, y * 15 + 200, z * 15); // Scale and offset
                }
                return arr;
            },

            // 2. Star (Geometric)
            createStar: () => {
                const arr = [];
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const r = 250 * Math.sqrt(Math.random());
                    const angle = Math.random() * Math.PI * 2;
                    const z = (Math.random() - 0.5) * 40;
                    
                    // Star shape logic (5 points)
                    const a = Math.atan2(Math.sin(angle), Math.cos(angle));
                    const seg = Math.PI / 5;
                    const rBase = (Math.floor((angle / seg)) % 2 === 0) ? 1.0 : 0.4;
                    // Interpolate between inner and outer radius for cleaner lines
                    
                    // Let's use a simpler parametric approach for a solid star
                    const k = 5; 
                    const m = 2; // Star sharpness
                    const pt = i / CONFIG.particleCount * Math.PI * 2 * k;
                    // Just filling a 2D star shape extruded
                    
                    // Standard 5-point star parametric
                    // Distribute random points inside a star polygon? 
                    // Let's do a trick: draw active pixels from canvas, same as text but for a shape?
                    // No, let's calculate math.
                    
                    let u = Math.random() * Math.PI * 2;
                    let len = 1;
                    // Check if inside star... simple star radius fn:
                    const n = 5;
                    const R = 300;
                    const r_in = 120;
                    
                    // Angle logic
                    let theta = Math.atan2(Math.sin(u), Math.cos(u));
                    let localTheta = theta % (2 * Math.PI / n);
                    // Approximate star distribution
                    
                    // Fallback to simple composition: 5 triangles + center pentagon
                    // Or simply:
                    const rad = 300;
                    const spike = 5;
                    const v = 0.5; // inner radius ratio
                    const step = Math.PI / spike;
                    
                    // Random point in circle, discard if outside star
                    let valid = false;
                    let sx, sy;
                    while(!valid) {
                         sx = (Math.random() - 0.5) * 2 * rad;
                         sy = (Math.random() - 0.5) * 2 * rad;
                         const ang = Math.atan2(sy, sx);
                         const mag = Math.sqrt(sx*sx + sy*sy);
                         
                         // Star boundary function
                         const alpha = (ang + Math.PI) % (2 * Math.PI / spike) - (Math.PI / spike);
                         const boundary = rad * Math.cos(Math.PI/spike) / Math.cos(alpha); // Pentagon
                         // Real star is harder, let's approximate with distance modulation
                         const wave = Math.abs(Math.cos(ang * 2.5)); // 5 spikes
                         const limit = rad * (0.3 + 0.7 * wave); 
                         if (mag < limit) valid = true;
                    }
                    
                    arr.push(sx, sy, z);
                }
                return arr;
            },

            // 3. Flower (Sakura)
            createFlower: () => {
                const arr = [];
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const t = Math.random() * Math.PI * 2; // angle
                    // Rose curve r = cos(k * theta)
                    const k = 5; // 5 petals
                    const rMax = 300;
                    const rShape = Math.abs(Math.cos(k * t * 0.5)); // 0.5 makes it wider/rounded
                    const r = Math.random() * rMax * rShape;
                    
                    const x = r * Math.cos(t);
                    const y = r * Math.sin(t);
                    const z = (Math.random() - 0.5) * (100 - r * 0.2); // Curled edges
                    
                    arr.push(x, y, z);
                }
                return arr;
            },

            // 4. Note / Text via Canvas
            createFromCanvas: (text, size = 300) => {
                const w = 500;
                const h = 500;
                textCanvas.width = w;
                textCanvas.height = h;
                textCtx.clearRect(0,0,w,h);
                textCtx.fillStyle = 'white';
                textCtx.font = `bold ${size}px Arial`;
                textCtx.textAlign = 'center';
                textCtx.textBaseline = 'middle';
                textCtx.fillText(text, w/2, h/2);
                
                const imageData = textCtx.getImageData(0,0,w,h).data;
                const activePixels = [];
                for(let y=0; y<h; y+=4) { // stride for performance
                    for(let x=0; x<w; x+=4) {
                        const idx = (y*w + x) * 4;
                        if(imageData[idx] > 128) {
                            activePixels.push({x: x - w/2, y: -(y - h/2)}); // Flip Y
                        }
                    }
                }
                
                const arr = [];
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const p = activePixels[Math.floor(Math.random() * activePixels.length)];
                    if(p) {
                        arr.push(p.x * 1.5, p.y * 1.5, (Math.random()-0.5)*20);
                    } else {
                        arr.push(0,0,0);
                    }
                }
                return arr;
            },

            // 5. Scatter (Sphere/Cloud)
            createScatter: () => {
                const arr = [];
                for(let i=0; i<CONFIG.particleCount; i++) {
                   const p = ShapeUtils.getSpherePoint(600 + Math.random() * 400);
                   arr.push(p.x, p.y, p.z);
                }
                return arr;
            }
        };

        // ==========================================
        // MAIN 3D SCENE
        // ==========================================
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            // Scene & Camera
            scene = new THREE.Scene();
            // Fog for depth
            scene.fog = new THREE.FogExp2(0x050505, 0.001);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.z = 800;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // Create Geometry
            geometry = new THREE.BufferGeometry();
            
            // Init arrays
            const initialPos = ShapeUtils.createScatter();
            for(let i=0; i<CONFIG.particleCount; i++) {
                const i3 = i * 3;
                positions[i3] = initialPos[i3];
                positions[i3+1] = initialPos[i3+1];
                positions[i3+2] = initialPos[i3+2];
                
                targets[i3] = initialPos[i3];
                targets[i3+1] = initialPos[i3+1];
                targets[i3+2] = initialPos[i3+2];
                
                velocities[i3] = (Math.random() - 0.5) * 2;
                velocities[i3+1] = (Math.random() - 0.5) * 2;
                velocities[i3+2] = (Math.random() - 0.5) * 2;
                
                const col = CONFIG.colors.scatter;
                colors[i3] = col.r;
                colors[i3+1] = col.g;
                colors[i3+2] = col.b;
                
                sizes[i] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targets, 3)); // Helper, not used in shader directly now, using CPU lerp
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('sizeRandom', new THREE.BufferAttribute(sizes, 1));

            // Material
            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uPixelRatio: { value: renderer.getPixelRatio() },
                    uSize: { value: CONFIG.particleSize }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);

            // Background Stars (Static)
            addBackgroundStars();
            
            // Pre-calculate Shapes
            console.log("Generating shapes...");
            shapeCache.scatter = ShapeUtils.createScatter();
            shapeCache.heart = ShapeUtils.createHeart();
            shapeCache.star = ShapeUtils.createStar();
            shapeCache.flower = ShapeUtils.createFlower();
            shapeCache.note = ShapeUtils.createFromCanvas('♫', 350);
            shapeCache.text = ShapeUtils.createFromCanvas('LOVE', 200);
            console.log("Shapes ready.");

            window.addEventListener('resize', onWindowResize, false);
        }

        function addBackgroundStars() {
            const starGeo = new THREE.BufferGeometry();
            const starCount = 2000;
            const starPos = new Float32Array(starCount * 3);
            for(let i=0; i<starCount*3; i++) {
                starPos[i] = (Math.random() - 0.5) * 4000;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({
                color: 0x555555, size: 2, sizeAttenuation: false, transparent: true, opacity: 0.8
            });
            const stars = new THREE.Points(starGeo, starMat);
            scene.add(stars);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.uPixelRatio.value = renderer.getPixelRatio();
        }

        // ==========================================
        // ANIMATION LOOP
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            material.uniforms.uTime.value = time;

            // Breathing / Pulse Animation for shapes
            let pulseScale = 1.0;
            if (currentShape !== 'scatter') {
                pulseScale = 1.0 + Math.sin(time * 3) * 0.05; // Gentle heartbeat
                points.rotation.y = Math.sin(time * 0.2) * 0.1; // Slow sway
            } else {
                points.rotation.y += 0.001; // Slow spin for scatter
            }

            // Physics Update
            const positionsAttr = geometry.attributes.position;
            const colorsAttr = geometry.attributes.color;
            const posArr = positionsAttr.array;
            const colArr = colorsAttr.array;
            
            const targetShapeArr = shapeCache[currentShape] || shapeCache.scatter;

            // Color Transition
            const targetC = CONFIG.colors[currentShape] || CONFIG.colors.scatter;
            const lerpSpeed = 0.05;

            for(let i=0; i<CONFIG.particleCount; i++) {
                const i3 = i * 3;

                // 1. Get Target
                let tx = targetShapeArr[i3] * pulseScale;
                let ty = targetShapeArr[i3+1] * pulseScale;
                let tz = targetShapeArr[i3+2] * pulseScale;
                
                // If scatter, add dynamic noise
                if(currentShape === 'scatter') {
                    tx += Math.cos(time + i) * 50;
                    ty += Math.sin(time + i * 0.5) * 50;
                }

                // 2. Physics: Velocity += Force
                // Vector to target
                const dx = tx - posArr[i3];
                const dy = ty - posArr[i3+1];
                const dz = tz - posArr[i3+2];

                // Acceleration
                velocities[i3]     += dx * 0.005;
                velocities[i3+1]   += dy * 0.005;
                velocities[i3+2]   += dz * 0.005;

                // Friction
                velocities[i3]     *= 0.92;
                velocities[i3+1]   *= 0.92;
                velocities[i3+2]   *= 0.92;

                // Update Position
                posArr[i3]     += velocities[i3];
                posArr[i3+1]   += velocities[i3+1];
                posArr[i3+2]   += velocities[i3+2];

                // 3. Color Update (Lerp)
                colArr[i3] += (targetC.r - colArr[i3]) * lerpSpeed;
                colArr[i3+1] += (targetC.g - colArr[i3+1]) * lerpSpeed;
                colArr[i3+2] += (targetC.b - colArr[i3+2]) * lerpSpeed;
                
                // Velocity color flair (brighter when moving fast)
                const speed = Math.abs(velocities[i3]) + Math.abs(velocities[i3+1]);
                if (speed > 2.0 && currentShape === 'scatter') {
                    colArr[i3] += 0.1; 
                    colArr[i3+1] += 0.1;
                    colArr[i3+2] += 0.1;
                }
            }

            positionsAttr.needsUpdate = true;
            colorsAttr.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // ==========================================
        // MEDIAPIPE LOGIC
        // ==========================================
        async function setupMediaPipe() {
            // Dynamically import MediaPipe script contents then initialize
            const videoElement = document.getElementById('input-video');
            
            // Load Hands library script
            const script = document.createElement('script');
            script.src = "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js";
            script.crossOrigin = "anonymous";
            script.onload = async () => {
                const hands = new window.Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.6,
                    minTrackingConfidence: 0.5
                });

                hands.onResults(onHandsResults);

                // Camera Utils not strictly needed if we just use requestAnimationFrame loop to send video
                // But let's verify getUserMedia first
                startCamera(hands, videoElement);
            };
            document.body.appendChild(script);
        }

        async function startCamera(handsInstance, videoElement) {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                videoElement.srcObject = stream;
                videoElement.play();
                
                // Remove loader
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 800);

                // Detection Loop
                const cameraLoop = async () => {
                    if (videoElement.readyState >= 2) {
                        await handsInstance.send({image: videoElement});
                    }
                    requestAnimationFrame(cameraLoop);
                };
                cameraLoop();

            } catch (err) {
                alert("摄像头权限似乎被拒绝了呢");
                document.getElementById('loader-text').innerText = "CAMERA ERROR - DEMO MODE";
                setTimeout(() => {
                     document.getElementById('loader').style.display = 'none';
                }, 2000);
            }
        }

        // GESTURE RECOGNITION
        function onHandsResults(results) {
            const statusEl = document.getElementById('status');
            const nameEl = document.getElementById('gesture-name');
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                statusEl.innerText = "TRACKING ACTIVE";
                statusEl.style.color = "#00f3ff";

                const lm = results.multiHandLandmarks[0];
                detectGesture(lm, nameEl);
            } else {
                isHandDetected = false;
                statusEl.innerText = "试着摆个手势吧~⭐";
                statusEl.style.color = "gray";
                
                // Optionally maintain last shape or drift back to scatter
                // currentShape = 'scatter'; 
            }
        }

        function detectGesture(landmarks, labelEl) {
            // Landmarks: 0=wrist, 4=thumb_tip, 8=index_tip, 12=middle_tip, 16=ring_tip, 20=pinky_tip
            // Determine if fingers are extended (Tip y < PIP y is a rough heuristic for "Up" in 2D, 
            // but dist from palm base (0) is more robust for 3D/Z-depth)
            
            const isFingerUp = (tipIdx, pipIdx) => {
                // Simple distance check: is tip further from wrist than pip?
                const distTip = dist(landmarks[0], landmarks[tipIdx]);
                const distPip = dist(landmarks[0], landmarks[pipIdx]);
                return distTip > distPip + 0.05; // Threshold
            };
            
            // Specifically for Thumb (different mechanics)
            const isThumbUp = () => {
                 const distTip = dist(landmarks[17], landmarks[4]); // Dist from pinky base
                 const distKnuckle = dist(landmarks[17], landmarks[2]);
                 return distTip > distKnuckle;
            }

            const thumb = isThumbUp();
            const index = isFingerUp(8, 6);
            const middle = isFingerUp(12, 10);
            const ring = isFingerUp(16, 14);
            const pinky = isFingerUp(20, 18);
            
            const count = (thumb?1:0) + (index?1:0) + (middle?1:0) + (ring?1:0) + (pinky?1:0);

            let detected = '';

            // LOGIC MAPPING
            // 1. Fist (Closed) -> Heart
            if (count === 0) {
                detected = 'heart';
                labelEl.innerText = "♥ 爱心 ♥";
            }
            // 2. Open Palm (All 5) -> Explosion
            else if (count === 5) {
                detected = 'scatter';
                labelEl.innerText = ">>> 试着摆个漂亮的手势~ <<<";
            }
            // 3. V Sign (Index + Middle) -> Star
            else if (index && middle && !ring && !pinky) {
                detected = 'star';
                labelEl.innerText = "★ 比耶的样子很靓噢 ★";
            }
            // 4. Rock/Horns (Index + Pinky + Thumb usually, or just I+P) -> Note
            else if (index && pinky && !middle && !ring) {
                detected = 'note';
                labelEl.innerText = "♫ 一起摇滚！ ♫";
            }
            // 5. Four fingers up + Thumb in -> LOVE
            else if (index && middle && ring && pinky && !thumb) {
                detected = 'text';
                labelEl.innerText = "❤LOVE XR0❤";
            }
            else {
                // Ambiguous - keep previous or default
                // detected = currentShape; 
                // labelEl.innerText = "...";
                return;
            }

            if (detected && detected !== currentShape) {
                triggerTransition(detected);
            }
        }

        function triggerTransition(newShape) {
            currentShape = newShape;
            
            // Add a little "Explosion" velocity impulse when switching
            for(let i=0; i<CONFIG.particleCount; i++) {
                const i3 = i * 3;
                velocities[i3] += (Math.random()-0.5) * 2;
                velocities[i3+1] += (Math.random()-0.5) * 2;
                velocities[i3+2] += (Math.random()-0.5) * 2;
            }
        }

        function dist(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            return Math.sqrt(dx*dx + dy*dy);
        }

        // ==========================================
        // INITIALIZATION FLOW
        // ==========================================
        window.onload = () => {
            initThree();
            animate();

            const startBtn = document.getElementById('start-btn');
            const loaderText = document.getElementById('loader-text');

            // Simulate "System Check"
            setTimeout(() => {
                loaderText.innerText = "我已经准备好咯~但是你没给权限呢？！";
                startBtn.style.display = 'block';
            }, 1000);

            startBtn.addEventListener('click', () => {
                startBtn.innerText = "ACCESSING...";
                setupMediaPipe();
            });

            // Camera Toggle
            const camToggle = document.getElementById('cam-toggle');
            const videoPreview = document.getElementById('camera-container');
            let camVisible = true;
            camToggle.addEventListener('click', () => {
                camVisible = !camVisible;
                videoPreview.style.display = camVisible ? 'block' : 'none';
            });
        };

    </script>
</body>

</html>
