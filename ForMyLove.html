<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cyberpunk Hand Particles - Ultimate Edition</title>
    <style>
        :root {
            --primary: #00f3ff;
            --secondary: #ff0055;
            --bg: #050505;
        }
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Rajdhani', 'Segoe UI', sans-serif;
            color: white;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        /* ËßÜÈ¢ëÈöêËóèÔºåÂè™Áî®‰∫éËØÜÂà´ */
        #video-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            object-fit: cover;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            transform: scaleX(-1); /* ÈïúÂÉè */
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        #video-feed.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .gesture-indicator {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: right;
        }
        
        .gesture-name {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
            text-shadow: 0 0 10px var(--primary);
            text-transform: uppercase;
        }

        .fps-counter {
            font-size: 12px;
            color: #888;
        }

        .controls {
            pointer-events: auto;
            display: flex;
            gap: 10px;
        }

        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            background: var(--primary);
            color: black;
            box-shadow: 0 0 15px var(--primary);
        }

        /* Loading Screen */
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.8s ease-out;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 243, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        .loading-text {
            font-size: 14px;
            color: #aaa;
            letter-spacing: 2px;
        }

        .guide-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
        }
        .guide-overlay.visible {
            opacity: 1;
        }
        .guide-item {
            margin: 10px 0;
            font-size: 14px;
            color: rgba(255,255,255,0.7);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <video id="video-feed" autoplay playsinline muted></video>

    <div id="ui-layer">
        <div class="status-bar">
            <div class="controls">
                <button id="btn-cam">Stop Cam</button>
                <button id="btn-debug">Show Video</button>
            </div>
            <div class="gesture-indicator">
                <div class="fps-counter">SYSTEM READY</div>
                <div class="gesture-name" id="gesture-text">WAITING...</div>
            </div>
        </div>
        
        <div class="guide-overlay" id="guide">
            <div class="guide-item">‚úä Fist = Heart</div>
            <div class="guide-item">üñê Open = Explode</div>
            <div class="guide-item">‚úåÔ∏è V-Sign = Star</div>
            <div class="guide-item">ü§ò Rock = Music Note</div>
            <div class="guide-item">‚úã (Thumb In) = LOVE</div>
        </div>
    </div>

    <div id="loading-screen">
        <div class="loader"></div>
        <div class="loading-text" id="loading-msg">INITIALIZING NEURAL NETWORK...</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // ================= CONFIGURATION =================
        const CONFIG = {
            particleCount: 12000,
            camWidth: 640,
            camHeight: 480,
            colors: {
                heart: new THREE.Color('#ff0055'),
                star: new THREE.Color('#ffcc00'),
                note: new THREE.Color('#00f3ff'),
                flower: new THREE.Color('#ff69b4'),
                love: new THREE.Color('#ffffff'), // Will be rainbow in shader
                explode: new THREE.Color('#ffffff')
            },
            transitionSpeed: 0.05,
            noiseStrength: 0.2
        };

        // ================= GLOBAL STATE =================
        const state = {
            targetShape: 'explode', // heart, star, note, love, explode, flower
            cameraActive: true,
            handDetected: false,
            time: 0,
            lastGesture: null,
            gestureConfidence: 0
        };

        // ================= UTILS & SHAPES =================
        
        // ÁîüÊàêÁà±ÂøÉÁÇπ‰∫ë
        function createHeartPoints(count) {
            const points = [];
            for (let i = 0; i < count; i++) {
                let t = Math.random() * Math.PI * 2;
                let r = Math.sqrt(Math.random()); // ÂùáÂåÄÂàÜÂ∏É
                // 3D Heart formula
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 4; // Thickness
                
                // Scale down
                x *= 0.35; y *= 0.35;
                
                // Volume fill
                x *= r; y *= r; z *= r;
                
                points.push(new THREE.Vector3(x, y, z));
            }
            return points;
        }

        // ÁîüÊàêÁêÉ‰Ωì/ÁàÜÁÇ∏ÂàùÂßãÁÇπ
        function createSpherePoints(count, radius = 20) {
            const points = [];
            for (let i = 0; i < count; i++) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = Math.cbrt(Math.random()) * radius; // ÂùáÂåÄÁêÉ‰ΩìÂàÜÂ∏É
                let x = r * Math.sin(phi) * Math.cos(theta);
                let y = r * Math.sin(phi) * Math.sin(theta);
                let z = r * Math.cos(phi);
                points.push(new THREE.Vector3(x, y, z));
            }
            return points;
        }

        // ÁîüÊàê‰∫îËßíÊòü
        function createStarPoints(count) {
            const points = [];
            for (let i = 0; i < count; i++) {
                // ÁÆÄÂçïÁöÑ‰∫îËßíÊòüÈÄªËæëÔºöÊûÅÂùêÊ†áÔºårÈöèËßíÂ∫¶ÂèòÂåñ
                const angle = Math.random() * Math.PI * 2;
                const segment = angle / (Math.PI * 2 / 5);
                const t = (segment - Math.floor(segment)) * 2; // 0..2
                
                // ÊòüÂΩ¢ÂçäÂæÑËÆ°ÁÆó
                const outer = 6;
                const inner = 2.5;
                const rCalc = (t < 1) ? 
                    inner + (outer - inner) * t : 
                    outer - (outer - inner) * (t - 1);
                
                const r = rCalc * Math.sqrt(Math.random()); // Fill
                const x = r * Math.cos(angle);
                const y = r * Math.sin(angle);
                const z = (Math.random() - 0.5) * 1.5;
                points.push(new THREE.Vector3(x, y, z));
            }
            return points;
        }

        // ÁîüÊàêÈü≥Á¨¶ ‚ô´
        function createNotePoints(count) {
            const points = [];
            // Áî®ÁÆÄÂçïÁöÑÂèÇÊï∞ÊñπÁ®ãÊ®°Êãü‰∏§‰∏™Ë±ÜËäΩÈü≥Á¨¶
            for(let i=0; i<count; i++) {
                const p = Math.random();
                let x, y, z;
                z = (Math.random() - 0.5) * 1;

                if (p < 0.2) { // Â∑¶Á¨¶Â§¥
                    const ang = Math.random() * Math.PI * 2;
                    const r = Math.sqrt(Math.random()) * 1.2;
                    x = -2 + r * Math.cos(ang);
                    y = -2 + r * Math.sin(ang) * 0.8; // Á®çÂæÆÊâÅ‰∏ÄÁÇπ
                } else if (p < 0.4) { // Âè≥Á¨¶Â§¥
                    const ang = Math.random() * Math.PI * 2;
                    const r = Math.sqrt(Math.random()) * 1.2;
                    x = 2 + r * Math.cos(ang);
                    y = -1.5 + r * Math.sin(ang) * 0.8;
                } else if (p < 0.7) { // Á¨¶Âπ≤
                    const h = Math.random() * 6; // È´òÂ∫¶
                    const w = (Math.random() - 0.5) * 0.2;
                    const side = Math.random() > 0.5 ? -2 : 2;
                    x = side + w;
                    y = -2 + h;
                    if(side > 0) y = -1.5 + h;
                } else { // Á¨¶Ê¢Å
                    const t = Math.random(); // 0 to 1
                    const xStart = -2; const xEnd = 2;
                    const yStart = 4; const yEnd = 4.5;
                    x = xStart + (xEnd - xStart) * t;
                    y = yStart + (yEnd - yStart) * t + (Math.random()-0.5)*0.5;
                    // Âä†Âéö
                    y -= Math.random() * 1.0;
                }
                points.push(new THREE.Vector3(x, y, z));
            }
            return points;
        }

        // ÁîüÊàêËä±Êúµ (Ê®±Ëä±)
        function createFlowerPoints(count) {
            const points = [];
            for (let i = 0; i < count; i++) {
                const u = Math.random();
                const v = Math.random();
                // ÊûÅÂùêÊ†áÁé´Áë∞Á∫ø r = cos(k*theta)
                const theta = u * Math.PI * 2;
                const k = 2.5; // 5 petals
                let rBase = Math.abs(Math.cos(k * theta)); 
                // ËÆ©Ëä±Áì£ÂúÜÊ∂¶‰∏ÄÁÇπ
                rBase = 0.5 + 0.5 * rBase;
                
                const r = 6 * rBase * Math.sqrt(v);
                
                let x = r * Math.cos(theta);
                let y = r * Math.sin(theta);
                // Ëä±ËäØÂáπÈô∑ÔºåËä±Áì£ËæπÁºòÁøòËµ∑
                let z = (rBase) * (Math.random() * 1); 
                points.push(new THREE.Vector3(x, y, z));
            }
            return points;
        }

        // ÈÄöËøá Canvas ÁîüÊàêÊñáÂ≠óÁÇπ‰∫ë "LOVE"
        function createTextPoints(text, count) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 100;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, 200, 100);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 100, 50);

            const imageData = ctx.getImageData(0, 0, 200, 100);
            const validPixels = [];
            for (let y = 0; y < 100; y += 2) {
                for (let x = 0; x < 200; x += 2) {
                    if (imageData.data[(y * 200 + x) * 4] > 128) {
                        validPixels.push({x, y});
                    }
                }
            }

            const points = [];
            if (validPixels.length === 0) return createSpherePoints(count);

            for (let i = 0; i < count; i++) {
                const pixel = validPixels[Math.floor(Math.random() * validPixels.length)];
                // Normalize and center
                const x = (pixel.x - 100) / 10;
                const y = -(pixel.y - 50) / 10; // Invert Y
                const z = (Math.random() - 0.5) * 1;
                // Add jitter
                points.push(new THREE.Vector3(x + Math.random()*0.2, y + Math.random()*0.2, z));
            }
            return points;
        }

        // ================= PARTICLE ENGINE =================

        class ParticleEngine {
            constructor(scene) {
                this.scene = scene;
                this.geometry = new THREE.BufferGeometry();
                
                // Attributes
                const positions = new Float32Array(CONFIG.particleCount * 3);
                const targets = new Float32Array(CONFIG.particleCount * 3);
                const velocities = new Float32Array(CONFIG.particleCount * 3); // For physics
                const sizes = new Float32Array(CONFIG.particleCount);
                const colors = new Float32Array(CONFIG.particleCount * 3);
                const randomness = new Float32Array(CONFIG.particleCount * 3);

                const baseColor = new THREE.Color();
                
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    positions[i*3] = (Math.random() - 0.5) * 50;
                    positions[i*3+1] = (Math.random() - 0.5) * 50;
                    positions[i*3+2] = (Math.random() - 0.5) * 50;
                    
                    targets[i*3] = positions[i*3]; // Start static
                    
                    sizes[i] = Math.random();
                    
                    randomness[i*3] = Math.random();
                    randomness[i*3+1] = Math.random();
                    randomness[i*3+2] = Math.random();
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3)); // Custom attr for shader/js mix
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                this.geometry.setAttribute('aRandom', new THREE.BufferAttribute(randomness, 3));
                
                // Shader Material
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uColor: { value: new THREE.Color(0.2, 0.5, 1.0) },
                        uIsExplode: { value: 1.0 }, // 1.0 = explode, 0.0 = form shape
                        uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) }
                    },
                    vertexShader: `
                        uniform float uTime;
                        uniform float uPixelRatio;
                        uniform float uIsExplode;
                        
                        attribute float size;
                        attribute vec3 aRandom;
                        
                        varying vec3 vPos;
                        varying float vAlpha;
                        varying float vSpeed;

                        // Simplex noise function (simplified)
                        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                        float snoise(vec3 v) { 
                          const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                          const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                          vec3 i  = floor(v + dot(v, C.yyy) );
                          vec3 x0 = v - i + dot(i, C.xxx) ;
                          vec3 g = step(x0.yzx, x0.xyz);
                          vec3 l = 1.0 - g;
                          vec3 i1 = min( g.xyz, l.zxy );
                          vec3 i2 = max( g.xyz, l.zxy );
                          vec3 x1 = x0 - i1 + C.xxx;
                          vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
                          vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
                          i = mod289(i); 
                          vec4 p = permute( permute( permute( 
                                     i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                                   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                                   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                          float n_ = 0.142857142857; // 1.0/7.0
                          vec3  ns = n_ * D.wyz - D.xzx;
                          vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
                          vec4 x_ = floor(j * ns.z);
                          vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
                          vec4 x = x_ *ns.x + ns.yyyy;
                          vec4 y = y_ *ns.x + ns.yyyy;
                          vec4 h = 1.0 - abs(x) - abs(y);
                          vec4 b0 = vec4( x.xy, y.xy );
                          vec4 b1 = vec4( x.zw, y.zw );
                          vec4 s0 = floor(b0)*2.0 + 1.0;
                          vec4 s1 = floor(b1)*2.0 + 1.0;
                          vec4 sh = -step(h, vec4(0.0));
                          vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                          vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                          vec3 p0 = vec3(a0.xy,h.x);
                          vec3 p1 = vec3(a0.zw,h.y);
                          vec3 p2 = vec3(a1.xy,h.z);
                          vec3 p3 = vec3(a1.zw,h.w);
                          vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                          p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                          vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                          m = m * m;
                          return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                                        dot(p2,x2), dot(p3,x3) ) );
                        }

                        void main() {
                            vec3 pos = position;
                            vPos = pos;
                            
                            // ÁÆÄÂçïÁöÑÂëºÂê∏/ÊëÜÂä®ÊïàÊûú (based on noise)
                            float noiseVal = snoise(pos * 0.1 + uTime * 0.5);
                            
                            // Â¶ÇÊûúÊòØÂΩ¢Áä∂Ê®°ÂºèÔºåÂä†‰∏ÄÁÇπÂæÆÂ∞èÁöÑÊâ∞Âä®
                            if (uIsExplode < 0.5) {
                                pos += normal * noiseVal * 0.1;
                            }
                            
                            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                            gl_Position = projectionMatrix * mvPosition;
                            
                            // Size attenuation
                            gl_PointSize = (size * 10.0 + 2.0) * uPixelRatio * (1.0 / -mvPosition.z);
                            
                            // Speed calc approximation for color
                            vSpeed = noiseVal;
                            
                            // ÈÄèÊòéÂ∫¶ÈöèÊ∑±Â∫¶ÂèòÂåñ
                            vAlpha = smoothstep(50.0, 0.0, -mvPosition.z);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 uColor;
                        uniform float uIsExplode;
                        varying float vAlpha;
                        varying float vSpeed;
                        varying vec3 vPos;

                        void main() {
                            // Point Sprite Shape: Soft circle
                            vec2 xy = gl_PointCoord.xy - vec2(0.5);
                            float r = length(xy);
                            if (r > 0.5) discard;
                            
                            // Glow falloff
                            float glow = 1.0 - (r * 2.0);
                            glow = pow(glow, 1.5);
                            
                            vec3 finalColor = uColor;
                            
                            // Â¶ÇÊûúÊòØÁàÜÁÇ∏/LoveÊ®°ÂºèÔºå‰ΩøÁî®ÂΩ©ËôπËâ≤/‰ΩçÁΩÆËâ≤
                            if (uIsExplode > 0.5 || length(uColor - vec3(1.0)) < 0.1) {
                                // ÁÆÄÂçïÁöÑËâ≤Áõ∏ÂÅèÁßª
                                vec3 rainbow = 0.5 + 0.5 * cos(vSpeed * 3.0 + vPos.x * 0.1 + vec3(0, 2, 4));
                                finalColor = mix(uColor, rainbow, 0.5);
                            }
                            
                            // Ê†∏ÂøÉÈ´ò‰∫Æ
                            finalColor += vec3(0.8) * glow * glow;

                            gl_FragColor = vec4(finalColor, glow * vAlpha);
                        }
                    `,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                this.points = new THREE.Points(this.geometry, this.material);
                scene.add(this.points);
                
                // Store data for JS physics
                this.attrPos = this.geometry.attributes.position;
                this.attrTarget = this.geometry.attributes.target;
                
                // Target shapes cache
                this.shapes = {
                    heart: createHeartPoints(CONFIG.particleCount),
                    sphere: createSpherePoints(CONFIG.particleCount, 25),
                    star: createStarPoints(CONFIG.particleCount),
                    note: createNotePoints(CONFIG.particleCount),
                    flower: createFlowerPoints(CONFIG.particleCount),
                    love: createTextPoints("LOVE", CONFIG.particleCount)
                };
                
                // Set initial target to sphere/explode
                this.setShape('explode');
            }

            setShape(shapeName) {
                let targetPoints;
                let color;
                let isExplode = 0.0;
                
                switch(shapeName) {
                    case 'heart': 
                        targetPoints = this.shapes.heart; 
                        color = CONFIG.colors.heart;
                        break;
                    case 'star': 
                        targetPoints = this.shapes.star; 
                        color = CONFIG.colors.star;
                        break;
                    case 'note': 
                        targetPoints = this.shapes.note; 
                        color = CONFIG.colors.note;
                        break;
                    case 'flower': 
                        targetPoints = this.shapes.flower; 
                        color = CONFIG.colors.flower;
                        break;
                    case 'love': 
                        targetPoints = this.shapes.love; 
                        color = CONFIG.colors.love;
                        break;
                    case 'explode': 
                    default:
                        targetPoints = this.shapes.sphere; 
                        color = CONFIG.colors.explode;
                        isExplode = 1.0;
                        break;
                }
                
                // Update Target Attributes
                const arr = this.attrTarget.array;
                for(let i=0; i<CONFIG.particleCount; i++) {
                    // Â¶ÇÊûúÊòØÁàÜÁÇ∏ÔºåÁõÆÊ†áËÆæÂæóÂæàËøúÔºåÊàñËÄÖÂè™ÊòØÁî®Êù•ÂÅöÂºïÂäõ‰∏≠ÂøÉ
                    if (shapeName === 'explode') {
                         // Âú®ÁàÜÁÇ∏Ê®°Âºè‰∏ãÔºåTarget ÂÆûÈôÖ‰∏äÊòØÈÄüÂ∫¶ÊñπÂêëÔºåÊàë‰ª¨Âú® update ÈáåÂ§ÑÁêÜ
                         const p = targetPoints[i];
                         arr[i*3] = p.x * 3.0; // Expand
                         arr[i*3+1] = p.y * 3.0;
                         arr[i*3+2] = p.z * 3.0;
                    } else {
                        const p = targetPoints[i];
                        arr[i*3] = p.x;
                        arr[i*3+1] = p.y;
                        arr[i*3+2] = p.z;
                    }
                }
                
                // Update Uniforms
                // Use GSAP-like tweening for color manually if needed, but direct set is fine for now
                // Smooth color transition
                const startColor = this.material.uniforms.uColor.value.clone();
                const endColor = color;
                
                let alpha = 0;
                const colorTween = setInterval(() => {
                    alpha += 0.05;
                    if(alpha >= 1) {
                        alpha = 1;
                        clearInterval(colorTween);
                    }
                    this.material.uniforms.uColor.value.lerpColors(startColor, endColor, alpha);
                }, 16);
                
                this.material.uniforms.uIsExplode.value = isExplode;
            }

            update(dt, time) {
                this.material.uniforms.uTime.value = time;
                
                const posArr = this.attrPos.array;
                const targetArr = this.attrTarget.array;
                const isExplode = state.targetShape === 'explode';
                
                // Physics Simulation
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const idx = i * 3;
                    let px = posArr[idx];
                    let py = posArr[idx+1];
                    let pz = posArr[idx+2];
                    
                    let tx = targetArr[idx];
                    let ty = targetArr[idx+1];
                    let tz = targetArr[idx+2];

                    if (isExplode) {
                        // Explosion logic: drift away + curl noise simulation
                        // Simply: move away from center with some rotation
                        const speed = 0.2;
                        px += (px * 0.01) + Math.sin(time + py*0.1) * 0.05;
                        py += (py * 0.01) + Math.cos(time + px*0.1) * 0.05;
                        pz += (pz * 0.01);
                        
                        // Bounds check to reset
                        if (Math.abs(px) > 60 || Math.abs(py) > 60) {
                             px = (Math.random()-0.5) * 10;
                             py = (Math.random()-0.5) * 10;
                             pz = (Math.random()-0.5) * 10;
                        }
                    } else {
                        // Shape formation logic: Spring/Lerp to target
                        // Add breathing animation to target
                        const breathe = 1.0 + Math.sin(time * 3) * 0.05;
                        let finalTx = tx * breathe;
                        let finalTy = ty * breathe;
                        let finalTz = tz * breathe;
                        
                        // Rotation for shapes
                        const rotSpeed = 0.5;
                        const cosR = Math.cos(time * rotSpeed);
                        const sinR = Math.sin(time * rotSpeed);
                        // Rotate around Y
                        const rx = finalTx * cosR - finalTz * sinR;
                        const rz = finalTx * sinR + finalTz * cosR;
                        finalTx = rx;
                        finalTz = rz;

                        // Lerp
                        px += (finalTx - px) * CONFIG.transitionSpeed;
                        py += (finalTy - py) * CONFIG.transitionSpeed;
                        pz += (finalTz - pz) * CONFIG.transitionSpeed;
                    }

                    posArr[idx] = px;
                    posArr[idx+1] = py;
                    posArr[idx+2] = pz;
                }
                
                this.attrPos.needsUpdate = true;
                
                // Group Rotation (Camera orbit feel)
                if (isExplode) {
                     this.points.rotation.y = time * 0.1;
                } else {
                     // Reset group rotation when forming shape to keep it centered
                     this.points.rotation.y = THREE.MathUtils.lerp(this.points.rotation.y, 0, 0.1);
                }
            }
        }

        // ================= APP LOGIC =================

        class App {
            constructor() {
                this.setupThree();
                this.setupUI();
                this.initMediaPipe();
                this.loop();
            }

            setupThree() {
                this.scene = new THREE.Scene();
                // Nebula background
                const loader = new THREE.TextureLoader();
                // Create a noise texture procedurally or just use fog/color
                // Simple starfield
                this.scene.fog = new THREE.FogExp2(CONFIG.colors.explode, 0.002);
                
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.z = 40;

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                this.particles = new ParticleEngine(this.scene);

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    if (this.particles.material) {
                        this.particles.material.uniforms.uPixelRatio.value = Math.min(window.devicePixelRatio, 2);
                    }
                });
            }

            setupUI() {
                const guide = document.getElementById('guide');
                setTimeout(() => guide.classList.add('visible'), 2000);
                setTimeout(() => guide.classList.remove('visible'), 8000); // Hide after 6s

                document.getElementById('btn-cam').addEventListener('click', (e) => {
                    state.cameraActive = !state.cameraActive;
                    e.target.innerText = state.cameraActive ? "Stop Cam" : "Start Cam";
                    if(state.cameraActive) this.startCamera();
                    else this.stopCamera();
                });

                document.getElementById('btn-debug').addEventListener('click', (e) => {
                    const video = document.getElementById('video-feed');
                    video.classList.toggle('hidden');
                    e.target.innerText = video.classList.contains('hidden') ? "Show Video" : "Hide Video";
                });
            }

            async initMediaPipe() {
                try {
                    const vision = await FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
                    );
                    this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: {
                            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                            delegate: "GPU"
                        },
                        runningMode: "VIDEO",
                        numHands: 1
                    });
                    
                    document.getElementById('loading-screen').style.opacity = 0;
                    setTimeout(() => document.getElementById('loading-screen').remove(), 800);
                    
                    this.startCamera();
                } catch (e) {
                    console.error(e);
                    document.getElementById('loading-msg').innerText = "ERROR LOADING AI MODEL";
                }
            }

            async startCamera() {
                const video = document.getElementById('video-feed');
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert("Camera API not supported");
                    return;
                }
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: CONFIG.camWidth,
                            height: CONFIG.camHeight,
                            frameRate: { ideal: 30 }
                        }
                    });
                    video.srcObject = stream;
                    video.addEventListener('loadeddata', () => {
                        this.videoLoaded = true;
                    });
                } catch (err) {
                    console.error("Camera access denied", err);
                    alert("Please allow camera access for hand tracking.");
                }
            }
            
            stopCamera() {
                const video = document.getElementById('video-feed');
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                    video.srcObject = null;
                }
                this.videoLoaded = false;
            }

            detectGesture(landmarks) {
                // Landmarks: 0=Wrist, 4=ThumbTip, 8=IndexTip, 12=MiddleTip, 16=RingTip, 20=PinkyTip
                // Tips: 4, 8, 12, 16, 20
                // PIPs (knuckles): 2, 6, 10, 14, 18
                
                const isExtended = (tipIdx, pipIdx) => {
                    // Simple logic: Tip is higher (lower y value) than PIP joint?
                    // Note: In video coord, Y increases downwards.
                    // But hand orientation varies. Better use distance from wrist (0).
                    const dTip = Math.hypot(landmarks[tipIdx].x - landmarks[0].x, landmarks[tipIdx].y - landmarks[0].y);
                    const dPip = Math.hypot(landmarks[pipIdx].x - landmarks[0].x, landmarks[pipIdx].y - landmarks[0].y);
                    return dTip > dPip; 
                };
                
                // Specific thumb check (check x distance relative to palm for open/close)
                // Simplified: Thumb Tip distance to Pinky Base (17) vs Thumb IP (3) distance
                const thumbExt = isExtended(4, 2); 
                const indexExt = isExtended(8, 6);
                const middleExt = isExtended(12, 10);
                const ringExt = isExtended(16, 14);
                const pinkyExt = isExtended(20, 18);

                let gesture = 'explode'; // Default open

                const fingersUp = [thumbExt, indexExt, middleExt, ringExt, pinkyExt].filter(Boolean).length;

                // 1. FIST (0 or 1 finger up usually thumb sometimes false positive)
                if (fingersUp <= 1 && !indexExt && !middleExt && !pinkyExt) {
                    gesture = 'heart';
                }
                // 2. V-SIGN (Index + Middle)
                else if (indexExt && middleExt && !ringExt && !pinkyExt) {
                    gesture = 'star';
                }
                // 3. ROCK (Index + Pinky, Thumb optional)
                else if (indexExt && pinkyExt && !middleExt && !ringExt) {
                    gesture = 'note';
                }
                // 4. LOVE (4 fingers up, thumb IN)
                else if (!thumbExt && indexExt && middleExt && ringExt && pinkyExt) {
                    gesture = 'love';
                }
                // 5. FLOWER (Maybe just Middle + Ring + Index? Or just all 5 spread wide?)
                // Let's map "OK Sign" (Index+Thumb touch) or similar? 
                // Prompt asked for specific mappings. I will add Flower as a variation of Open Palm if fingers are spread wide?
                // Let's stick to the prompt rules.
                // Prompt: "Complete open palm -> Explode".
                // I'll make Flower trigger if the hand is open BUT palm facing up (requires 3D coord logic, hard in 2D).
                // Let's add a custom one: Three fingers up (Index, Middle, Ring) -> Flower.
                else if (indexExt && middleExt && ringExt && !pinkyExt) {
                    gesture = 'flower';
                }
                // 6. OPEN PALM (5 fingers)
                else if (fingersUp >= 4) {
                    gesture = 'explode';
                }

                return gesture;
            }

            loop() {
                const now = performance.now() * 0.001;
                state.time = now;

                // 1. Process Vision (throttled to save FPS)
                if (state.cameraActive && this.videoLoaded && this.handLandmarker) {
                    const video = document.getElementById('video-feed');
                    // Detect every frame is fine if GPU is good, otherwise use interval
                    let startTimeMs = performance.now();
                    const results = this.handLandmarker.detectForVideo(video, startTimeMs);
                    
                    if (results.landmarks.length > 0) {
                        state.handDetected = true;
                        const landmarks = results.landmarks[0];
                        const gesture = this.detectGesture(landmarks);
                        
                        // Debounce
                        if (gesture !== state.lastGesture) {
                            state.gestureConfidence++;
                            if (state.gestureConfidence > 2) { // 3 frames consistent
                                state.targetShape = gesture;
                                this.particles.setShape(gesture);
                                state.lastGesture = gesture;
                                
                                const uiText = document.getElementById('gesture-text');
                                uiText.innerText = gesture.toUpperCase();
                                uiText.style.color = CONFIG.colors[gesture] ? '#' + CONFIG.colors[gesture].getHexString() : '#fff';
                                uiText.style.textShadow = `0 0 20px #${CONFIG.colors[gesture].getHexString()}`;
                                
                                state.gestureConfidence = 0;
                            }
                        } else {
                            state.gestureConfidence = 0;
                        }

                    } else {
                        state.handDetected = false;
                        // Optional: drift to idle state if no hand? Keeping last state is better for user exp.
                    }
                }

                // 2. Update Particles
                this.particles.update(0.016, now);

                // 3. Render
                this.renderer.render(this.scene, this.camera);

                requestAnimationFrame(() => this.loop());
            }
        }

        // Initialize
        window.onload = () => {
            const app = new App();
        };

    </script>
</body>
</html>
